<html>
<head>
<title>base_response.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #067d17;}
.s4 { color: #1750eb;}
.s5 { color: #8a822d;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
base_response.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">from </span><span class="s1">.._compat </span><span class="s0">import </span><span class="s1">integer_types</span>
<span class="s0">from </span><span class="s1">.._compat </span><span class="s0">import </span><span class="s1">string_types</span>
<span class="s0">from </span><span class="s1">.._compat </span><span class="s0">import </span><span class="s1">text_type</span>
<span class="s0">from </span><span class="s1">.._compat </span><span class="s0">import </span><span class="s1">to_bytes</span>
<span class="s0">from </span><span class="s1">.._compat </span><span class="s0">import </span><span class="s1">to_native</span>
<span class="s0">from </span><span class="s1">..datastructures </span><span class="s0">import </span><span class="s1">Headers</span>
<span class="s0">from </span><span class="s1">..http </span><span class="s0">import </span><span class="s1">dump_cookie</span>
<span class="s0">from </span><span class="s1">..http </span><span class="s0">import </span><span class="s1">HTTP_STATUS_CODES</span>
<span class="s0">from </span><span class="s1">..http </span><span class="s0">import </span><span class="s1">remove_entity_headers</span>
<span class="s0">from </span><span class="s1">..urls </span><span class="s0">import </span><span class="s1">iri_to_uri</span>
<span class="s0">from </span><span class="s1">..urls </span><span class="s0">import </span><span class="s1">url_join</span>
<span class="s0">from </span><span class="s1">..utils </span><span class="s0">import </span><span class="s1">get_content_type</span>
<span class="s0">from </span><span class="s1">..wsgi </span><span class="s0">import </span><span class="s1">ClosingIterator</span>
<span class="s0">from </span><span class="s1">..wsgi </span><span class="s0">import </span><span class="s1">get_current_url</span>


<span class="s0">def </span><span class="s1">_run_wsgi_app(*args):</span>
    <span class="s2">&quot;&quot;&quot;This function replaces itself to ensure that the test module is not 
    imported unless required.  DO NOT USE! 
    &quot;&quot;&quot;</span>
    <span class="s0">global </span><span class="s1">_run_wsgi_app</span>
    <span class="s0">from </span><span class="s1">..test </span><span class="s0">import </span><span class="s1">run_wsgi_app </span><span class="s0">as </span><span class="s1">_run_wsgi_app</span>

    <span class="s0">return </span><span class="s1">_run_wsgi_app(*args)</span>


<span class="s0">def </span><span class="s1">_warn_if_string(iterable):</span>
    <span class="s2">&quot;&quot;&quot;Helper for the response objects to check if the iterable returned 
    to the WSGI server is not a string. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(iterable, string_types):</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;Response iterable was set to a string. This will appear to&quot;</span>
            <span class="s3">&quot; work but means that the server will send the data to the&quot;</span>
            <span class="s3">&quot; client one character at a time. This is almost never&quot;</span>
            <span class="s3">&quot; intended behavior, use 'response.data' to assign strings&quot;</span>
            <span class="s3">&quot; to the response object.&quot;</span><span class="s1">,</span>
            <span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">,</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_iter_encoded(iterable, charset):</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">iterable:</span>
        <span class="s0">if </span><span class="s1">isinstance(item, text_type):</span>
            <span class="s0">yield </span><span class="s1">item.encode(charset)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">item</span>


<span class="s0">def </span><span class="s1">_clean_accept_ranges(accept_ranges):</span>
    <span class="s0">if </span><span class="s1">accept_ranges </span><span class="s0">is True</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s3">&quot;bytes&quot;</span>
    <span class="s0">elif </span><span class="s1">accept_ranges </span><span class="s0">is False</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s3">&quot;none&quot;</span>
    <span class="s0">elif </span><span class="s1">isinstance(accept_ranges, text_type):</span>
        <span class="s0">return </span><span class="s1">to_native(accept_ranges)</span>
    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid accept_ranges value&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">BaseResponse(object):</span>
    <span class="s2">&quot;&quot;&quot;Base response class.  The most important fact about a response object 
    is that it's a regular WSGI application.  It's initialized with a couple 
    of response parameters (headers, body, status code etc.) and will start a 
    valid WSGI response when called with the environ and start response 
    callable. 
 
    Because it's a WSGI application itself processing usually ends before the 
    actual response is sent to the server.  This helps debugging systems 
    because they can catch all the exceptions before responses are started. 
 
    Here a small example WSGI application that takes advantage of the 
    response objects:: 
 
        from werkzeug.wrappers import BaseResponse as Response 
 
        def index(): 
            return Response('Index page') 
 
        def application(environ, start_response): 
            path = environ.get('PATH_INFO') or '/' 
            if path == '/': 
                response = index() 
            else: 
                response = Response('Not Found', status=404) 
            return response(environ, start_response) 
 
    Like :class:`BaseRequest` which object is lacking a lot of functionality 
    implemented in mixins.  This gives you a better control about the actual 
    API of your response objects, so you can create subclasses and add custom 
    functionality.  A full featured response object is available as 
    :class:`Response` which implements a couple of useful mixins. 
 
    To enforce a new type of already existing responses you can use the 
    :meth:`force_type` method.  This is useful if you're working with different 
    subclasses of response objects and you want to post process them with a 
    known interface. 
 
    Per default the response object will assume all the text data is `utf-8` 
    encoded.  Please refer to :doc:`the unicode chapter &lt;/unicode&gt;` for more 
    details about customizing the behavior. 
 
    Response can be any kind of iterable or string.  If it's a string it's 
    considered being an iterable with one item which is the string passed. 
    Headers can be a list of tuples or a 
    :class:`~werkzeug.datastructures.Headers` object. 
 
    Special note for `mimetype` and `content_type`:  For most mime types 
    `mimetype` and `content_type` work the same, the difference affects 
    only 'text' mimetypes.  If the mimetype passed with `mimetype` is a 
    mimetype starting with `text/`, the charset parameter of the response 
    object is appended to it.  In contrast the `content_type` parameter is 
    always added as header unmodified. 
 
    .. versionchanged:: 0.5 
       the `direct_passthrough` parameter was added. 
 
    :param response: a string or response iterable. 
    :param status: a string with a status or an integer with the status code. 
    :param headers: a list of headers or a 
                    :class:`~werkzeug.datastructures.Headers` object. 
    :param mimetype: the mimetype for the response.  See notice above. 
    :param content_type: the content type for the response.  See notice above. 
    :param direct_passthrough: if set to `True` :meth:`iter_encoded` is not 
                               called before iteration which makes it 
                               possible to pass special iterators through 
                               unchanged (see :func:`wrap_file` for more 
                               details.) 
    &quot;&quot;&quot;</span>

    <span class="s2">#: the charset of the response.</span>
    <span class="s1">charset = </span><span class="s3">&quot;utf-8&quot;</span>

    <span class="s2">#: the default status if none is provided.</span>
    <span class="s1">default_status = </span><span class="s4">200</span>

    <span class="s2">#: the default mimetype if none is provided.</span>
    <span class="s1">default_mimetype = </span><span class="s3">&quot;text/plain&quot;</span>

    <span class="s2">#: if set to `False` accessing properties on the response object will</span>
    <span class="s2">#: not try to consume the response iterator and convert it into a list.</span>
    <span class="s2">#:</span>
    <span class="s2">#: .. versionadded:: 0.6.2</span>
    <span class="s2">#:</span>
    <span class="s2">#:    That attribute was previously called `implicit_seqence_conversion`.</span>
    <span class="s2">#:    (Notice the typo).  If you did use this feature, you have to adapt</span>
    <span class="s2">#:    your code to the name change.</span>
    <span class="s1">implicit_sequence_conversion = </span><span class="s0">True</span>

    <span class="s2">#: Should this response object correct the location header to be RFC</span>
    <span class="s2">#: conformant?  This is true by default.</span>
    <span class="s2">#:</span>
    <span class="s2">#: .. versionadded:: 0.8</span>
    <span class="s1">autocorrect_location_header = </span><span class="s0">True</span>

    <span class="s2">#: Should this response object automatically set the content-length</span>
    <span class="s2">#: header if possible?  This is true by default.</span>
    <span class="s2">#:</span>
    <span class="s2">#: .. versionadded:: 0.8</span>
    <span class="s1">automatically_set_content_length = </span><span class="s0">True</span>

    <span class="s2">#: Warn if a cookie header exceeds this size. The default, 4093, should be</span>
    <span class="s2">#: safely `supported by most browsers &lt;cookie_&gt;`_. A cookie larger than</span>
    <span class="s2">#: this size will still be sent, but it may be ignored or handled</span>
    <span class="s2">#: incorrectly by some browsers. Set to 0 to disable this check.</span>
    <span class="s2">#:</span>
    <span class="s2">#: .. versionadded:: 0.13</span>
    <span class="s2">#:</span>
    <span class="s2">#: .. _`cookie`: http://browsercookielimits.squawky.net/</span>
    <span class="s1">max_cookie_size = </span><span class="s4">4093</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">response=</span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">status=</span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">headers=</span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">mimetype=</span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">content_type=</span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">direct_passthrough=</span><span class="s0">False</span><span class="s1">,</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">isinstance(headers, Headers):</span>
            <span class="s1">self.headers = headers</span>
        <span class="s0">elif not </span><span class="s1">headers:</span>
            <span class="s1">self.headers = Headers()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.headers = Headers(headers)</span>

        <span class="s0">if </span><span class="s1">content_type </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">mimetype </span><span class="s0">is None and </span><span class="s3">&quot;content-type&quot; </span><span class="s0">not in </span><span class="s1">self.headers:</span>
                <span class="s1">mimetype = self.default_mimetype</span>
            <span class="s0">if </span><span class="s1">mimetype </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">mimetype = get_content_type(mimetype, self.charset)</span>
            <span class="s1">content_type = mimetype</span>
        <span class="s0">if </span><span class="s1">content_type </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.headers[</span><span class="s3">&quot;Content-Type&quot;</span><span class="s1">] = content_type</span>
        <span class="s0">if </span><span class="s1">status </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">status = self.default_status</span>
        <span class="s0">if </span><span class="s1">isinstance(status, integer_types):</span>
            <span class="s1">self.status_code = status</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.status = status</span>

        <span class="s1">self.direct_passthrough = direct_passthrough</span>
        <span class="s1">self._on_close = []</span>

        <span class="s2"># we set the response after the headers so that if a class changes</span>
        <span class="s2"># the charset attribute, the data is set in the correct charset.</span>
        <span class="s0">if </span><span class="s1">response </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.response = []</span>
        <span class="s0">elif </span><span class="s1">isinstance(response, (text_type, bytes, bytearray)):</span>
            <span class="s1">self.set_data(response)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.response = response</span>

    <span class="s0">def </span><span class="s1">call_on_close(self, func):</span>
        <span class="s2">&quot;&quot;&quot;Adds a function to the internal list of functions that should 
        be called as part of closing down the response.  Since 0.7 this 
        function also returns the function that was passed so that this 
        can be used as a decorator. 
 
        .. versionadded:: 0.6 
        &quot;&quot;&quot;</span>
        <span class="s1">self._on_close.append(func)</span>
        <span class="s0">return </span><span class="s1">func</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">if </span><span class="s1">self.is_sequence:</span>
            <span class="s1">body_info = </span><span class="s3">&quot;%d bytes&quot; </span><span class="s1">% sum(map(len, self.iter_encoded()))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">body_info = </span><span class="s3">&quot;streamed&quot; </span><span class="s0">if </span><span class="s1">self.is_streamed </span><span class="s0">else </span><span class="s3">&quot;likely-streamed&quot;</span>
        <span class="s0">return </span><span class="s3">&quot;&lt;%s %s [%s]&gt;&quot; </span><span class="s1">% (self.__class__.__name__, body_info, self.status)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">force_type(cls, response, environ=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Enforce that the WSGI response is a response object of the current 
        type.  Werkzeug will use the :class:`BaseResponse` internally in many 
        situations like the exceptions.  If you call :meth:`get_response` on an 
        exception you will get back a regular :class:`BaseResponse` object, even 
        if you are using a custom subclass. 
 
        This method can enforce a given response type, and it will also 
        convert arbitrary WSGI callables into response objects if an environ 
        is provided:: 
 
            # convert a Werkzeug response object into an instance of the 
            # MyResponseClass subclass. 
            response = MyResponseClass.force_type(response) 
 
            # convert any WSGI application into a response object 
            response = MyResponseClass.force_type(response, environ) 
 
        This is especially useful if you want to post-process responses in 
        the main dispatcher and use functionality provided by your subclass. 
 
        Keep in mind that this will modify response objects in place if 
        possible! 
 
        :param response: a response object or wsgi application. 
        :param environ: a WSGI environment object. 
        :return: a response object. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(response, BaseResponse):</span>
            <span class="s0">if </span><span class="s1">environ </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;cannot convert WSGI application into response&quot;</span>
                    <span class="s3">&quot; objects without an environ&quot;</span>
                <span class="s1">)</span>
            <span class="s1">response = BaseResponse(*_run_wsgi_app(response, environ))</span>
        <span class="s1">response.__class__ = cls</span>
        <span class="s0">return </span><span class="s1">response</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_app(cls, app, environ, buffered=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Create a new response object from an application output.  This 
        works best if you pass it an application that returns a generator all 
        the time.  Sometimes applications may use the `write()` callable 
        returned by the `start_response` function.  This tries to resolve such 
        edge cases automatically.  But if you don't get the expected output 
        you should set `buffered` to `True` which enforces buffering. 
 
        :param app: the WSGI application to execute. 
        :param environ: the WSGI environment to execute against. 
        :param buffered: set to `True` to enforce buffering. 
        :return: a response object. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">cls(*_run_wsgi_app(app, environ, buffered))</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">status_code(self):</span>
        <span class="s2">&quot;&quot;&quot;The HTTP status code as a number.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._status_code</span>

    <span class="s1">@status_code.setter</span>
    <span class="s0">def </span><span class="s1">status_code(self, code):</span>
        <span class="s1">self._status_code = code</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self._status = </span><span class="s3">&quot;%d %s&quot; </span><span class="s1">% (code, HTTP_STATUS_CODES[code].upper())</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s1">self._status = </span><span class="s3">&quot;%d UNKNOWN&quot; </span><span class="s1">% code</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">status(self):</span>
        <span class="s2">&quot;&quot;&quot;The HTTP status code as a string.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._status</span>

    <span class="s1">@status.setter</span>
    <span class="s0">def </span><span class="s1">status(self, value):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self._status = to_native(value)</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Invalid status argument&quot;</span><span class="s1">)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self._status_code = int(self._status.split(</span><span class="s0">None</span><span class="s1">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s1">self._status_code = </span><span class="s4">0</span>
            <span class="s1">self._status = </span><span class="s3">&quot;0 %s&quot; </span><span class="s1">% self._status</span>
        <span class="s0">except </span><span class="s1">IndexError:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Empty status argument&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_data(self, as_text=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;The string representation of the request body.  Whenever you call 
        this property the request iterable is encoded and flattened.  This 
        can lead to unwanted behavior if you stream big data. 
 
        This behavior can be disabled by setting 
        :attr:`implicit_sequence_conversion` to `False`. 
 
        If `as_text` is set to `True` the return value will be a decoded 
        unicode string. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s1">self._ensure_sequence()</span>
        <span class="s1">rv = </span><span class="s5">b&quot;&quot;</span><span class="s1">.join(self.iter_encoded())</span>
        <span class="s0">if </span><span class="s1">as_text:</span>
            <span class="s1">rv = rv.decode(self.charset)</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">set_data(self, value):</span>
        <span class="s2">&quot;&quot;&quot;Sets a new string as response.  The value set must be either a 
        unicode or bytestring.  If a unicode string is set it's encoded 
        automatically to the charset of the response (utf-8 by default). 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s2"># if an unicode string is set, it's encoded directly so that we</span>
        <span class="s2"># can set the content length</span>
        <span class="s0">if </span><span class="s1">isinstance(value, text_type):</span>
            <span class="s1">value = value.encode(self.charset)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">value = bytes(value)</span>
        <span class="s1">self.response = [value]</span>
        <span class="s0">if </span><span class="s1">self.automatically_set_content_length:</span>
            <span class="s1">self.headers[</span><span class="s3">&quot;Content-Length&quot;</span><span class="s1">] = str(len(value))</span>

    <span class="s1">data = property(</span>
        <span class="s1">get_data,</span>
        <span class="s1">set_data,</span>
        <span class="s1">doc=</span><span class="s3">&quot;A descriptor that calls :meth:`get_data` and :meth:`set_data`.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">calculate_content_length(self):</span>
        <span class="s2">&quot;&quot;&quot;Returns the content length if available or `None` otherwise.&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self._ensure_sequence()</span>
        <span class="s0">except </span><span class="s1">RuntimeError:</span>
            <span class="s0">return None</span>
        <span class="s0">return </span><span class="s1">sum(len(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self.iter_encoded())</span>

    <span class="s0">def </span><span class="s1">_ensure_sequence(self, mutable=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;This method can be called by methods that need a sequence.  If 
        `mutable` is true, it will also ensure that the response sequence 
        is a standard Python list. 
 
        .. versionadded:: 0.6 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.is_sequence:</span>
            <span class="s2"># if we need a mutable object, we ensure it's a list.</span>
            <span class="s0">if </span><span class="s1">mutable </span><span class="s0">and not </span><span class="s1">isinstance(self.response, list):</span>
                <span class="s1">self.response = list(self.response)</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">self.direct_passthrough:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span>
                <span class="s3">&quot;Attempted implicit sequence conversion but the&quot;</span>
                <span class="s3">&quot; response object is in direct passthrough mode.&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">self.implicit_sequence_conversion:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span>
                <span class="s3">&quot;The response object required the iterable to be a&quot;</span>
                <span class="s3">&quot; sequence, but the implicit conversion was disabled.&quot;</span>
                <span class="s3">&quot; Call make_sequence() yourself.&quot;</span>
            <span class="s1">)</span>
        <span class="s1">self.make_sequence()</span>

    <span class="s0">def </span><span class="s1">make_sequence(self):</span>
        <span class="s2">&quot;&quot;&quot;Converts the response iterator in a list.  By default this happens 
        automatically if required.  If `implicit_sequence_conversion` is 
        disabled, this method is not automatically called and some properties 
        might raise exceptions.  This also encodes all the items. 
 
        .. versionadded:: 0.6 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self.is_sequence:</span>
            <span class="s2"># if we consume an iterable we have to ensure that the close</span>
            <span class="s2"># method of the iterable is called if available when we tear</span>
            <span class="s2"># down the response</span>
            <span class="s1">close = getattr(self.response, </span><span class="s3">&quot;close&quot;</span><span class="s1">, </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">self.response = list(self.iter_encoded())</span>
            <span class="s0">if </span><span class="s1">close </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">self.call_on_close(close)</span>

    <span class="s0">def </span><span class="s1">iter_encoded(self):</span>
        <span class="s2">&quot;&quot;&quot;Iter the response encoded with the encoding of the response. 
        If the response object is invoked as WSGI application the return 
        value of this method is used as application iterator unless 
        :attr:`direct_passthrough` was activated. 
        &quot;&quot;&quot;</span>
        <span class="s0">if __debug__</span><span class="s1">:</span>
            <span class="s1">_warn_if_string(self.response)</span>
        <span class="s2"># Encode in a separate function so that self.response is fetched</span>
        <span class="s2"># early.  This allows us to wrap the response with the return</span>
        <span class="s2"># value from get_app_iter or iter_encoded.</span>
        <span class="s0">return </span><span class="s1">_iter_encoded(self.response, self.charset)</span>

    <span class="s0">def </span><span class="s1">set_cookie(</span>
        <span class="s1">self,</span>
        <span class="s1">key,</span>
        <span class="s1">value=</span><span class="s3">&quot;&quot;</span><span class="s1">,</span>
        <span class="s1">max_age=</span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">expires=</span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">path=</span><span class="s3">&quot;/&quot;</span><span class="s1">,</span>
        <span class="s1">domain=</span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">secure=</span><span class="s0">False</span><span class="s1">,</span>
        <span class="s1">httponly=</span><span class="s0">False</span><span class="s1">,</span>
        <span class="s1">samesite=</span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Sets a cookie. The parameters are the same as in the cookie `Morsel` 
        object in the Python standard library but it accepts unicode data, too. 
 
        A warning is raised if the size of the cookie header exceeds 
        :attr:`max_cookie_size`, but the header will still be set. 
 
        :param key: the key (name) of the cookie to be set. 
        :param value: the value of the cookie. 
        :param max_age: should be a number of seconds, or `None` (default) if 
                        the cookie should last only as long as the client's 
                        browser session. 
        :param expires: should be a `datetime` object or UNIX timestamp. 
        :param path: limits the cookie to a given path, per default it will 
                     span the whole domain. 
        :param domain: if you want to set a cross-domain cookie.  For example, 
                       ``domain=&quot;.example.com&quot;`` will set a cookie that is 
                       readable by the domain ``www.example.com``, 
                       ``foo.example.com`` etc.  Otherwise, a cookie will only 
                       be readable by the domain that set it. 
        :param secure: If `True`, the cookie will only be available via HTTPS 
        :param httponly: disallow JavaScript to access the cookie.  This is an 
                         extension to the cookie standard and probably not 
                         supported by all browsers. 
        :param samesite: Limits the scope of the cookie such that it will only 
                         be attached to requests if those requests are 
                         &quot;same-site&quot;. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.headers.add(</span>
            <span class="s3">&quot;Set-Cookie&quot;</span><span class="s1">,</span>
            <span class="s1">dump_cookie(</span>
                <span class="s1">key,</span>
                <span class="s1">value=value,</span>
                <span class="s1">max_age=max_age,</span>
                <span class="s1">expires=expires,</span>
                <span class="s1">path=path,</span>
                <span class="s1">domain=domain,</span>
                <span class="s1">secure=secure,</span>
                <span class="s1">httponly=httponly,</span>
                <span class="s1">charset=self.charset,</span>
                <span class="s1">max_size=self.max_cookie_size,</span>
                <span class="s1">samesite=samesite,</span>
            <span class="s1">),</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">delete_cookie(self, key, path=</span><span class="s3">&quot;/&quot;</span><span class="s1">, domain=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Delete a cookie.  Fails silently if key doesn't exist. 
 
        :param key: the key (name) of the cookie to be deleted. 
        :param path: if the cookie that should be deleted was limited to a 
                     path, the path has to be defined here. 
        :param domain: if the cookie that should be deleted was limited to a 
                       domain, that domain has to be defined here. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.set_cookie(key, expires=</span><span class="s4">0</span><span class="s1">, max_age=</span><span class="s4">0</span><span class="s1">, path=path, domain=domain)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_streamed(self):</span>
        <span class="s2">&quot;&quot;&quot;If the response is streamed (the response is not an iterable with 
        a length information) this property is `True`.  In this case streamed 
        means that there is no information about the number of iterations. 
        This is usually `True` if a generator is passed to the response object. 
 
        This is useful for checking before applying some sort of post 
        filtering that should not take place for streamed responses. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">len(self.response)</span>
        <span class="s0">except </span><span class="s1">(TypeError, AttributeError):</span>
            <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_sequence(self):</span>
        <span class="s2">&quot;&quot;&quot;If the iterator is buffered, this property will be `True`.  A 
        response object will consider an iterator to be buffered if the 
        response attribute is a list or tuple. 
 
        .. versionadded:: 0.6 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">isinstance(self.response, (tuple, list))</span>

    <span class="s0">def </span><span class="s1">close(self):</span>
        <span class="s2">&quot;&quot;&quot;Close the wrapped response if possible.  You can also use the object 
        in a with statement which will automatically close it. 
 
        .. versionadded:: 0.9 
           Can now be used in a with statement. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">hasattr(self.response, </span><span class="s3">&quot;close&quot;</span><span class="s1">):</span>
            <span class="s1">self.response.close()</span>
        <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">self._on_close:</span>
            <span class="s1">func()</span>

    <span class="s0">def </span><span class="s1">__enter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(self, exc_type, exc_value, tb):</span>
        <span class="s1">self.close()</span>

    <span class="s0">def </span><span class="s1">freeze(self):</span>
        <span class="s2">&quot;&quot;&quot;Call this method if you want to make your response object ready for 
        being pickled.  This buffers the generator if there is one.  It will 
        also set the `Content-Length` header to the length of the body. 
 
        .. versionchanged:: 0.6 
           The `Content-Length` header is now set. 
        &quot;&quot;&quot;</span>
        <span class="s2"># we explicitly set the length to a list of the *encoded* response</span>
        <span class="s2"># iterator.  Even if the implicit sequence conversion is disabled.</span>
        <span class="s1">self.response = list(self.iter_encoded())</span>
        <span class="s1">self.headers[</span><span class="s3">&quot;Content-Length&quot;</span><span class="s1">] = str(sum(map(len, self.response)))</span>

    <span class="s0">def </span><span class="s1">get_wsgi_headers(self, environ):</span>
        <span class="s2">&quot;&quot;&quot;This is automatically called right before the response is started 
        and returns headers modified for the given environment.  It returns a 
        copy of the headers from the response with some modifications applied 
        if necessary. 
 
        For example the location header (if present) is joined with the root 
        URL of the environment.  Also the content length is automatically set 
        to zero here for certain status codes. 
 
        .. versionchanged:: 0.6 
           Previously that function was called `fix_headers` and modified 
           the response object in place.  Also since 0.6, IRIs in location 
           and content-location headers are handled properly. 
 
           Also starting with 0.6, Werkzeug will attempt to set the content 
           length if it is able to figure it out on its own.  This is the 
           case if all the strings in the response iterable are already 
           encoded and the iterable is buffered. 
 
        :param environ: the WSGI environment of the request. 
        :return: returns a new :class:`~werkzeug.datastructures.Headers` 
                 object. 
        &quot;&quot;&quot;</span>
        <span class="s1">headers = Headers(self.headers)</span>
        <span class="s1">location = </span><span class="s0">None</span>
        <span class="s1">content_location = </span><span class="s0">None</span>
        <span class="s1">content_length = </span><span class="s0">None</span>
        <span class="s1">status = self.status_code</span>

        <span class="s2"># iterate over the headers to find all values in one go.  Because</span>
        <span class="s2"># get_wsgi_headers is used each response that gives us a tiny</span>
        <span class="s2"># speedup.</span>
        <span class="s0">for </span><span class="s1">key, value </span><span class="s0">in </span><span class="s1">headers:</span>
            <span class="s1">ikey = key.lower()</span>
            <span class="s0">if </span><span class="s1">ikey == </span><span class="s3">u&quot;location&quot;</span><span class="s1">:</span>
                <span class="s1">location = value</span>
            <span class="s0">elif </span><span class="s1">ikey == </span><span class="s3">u&quot;content-location&quot;</span><span class="s1">:</span>
                <span class="s1">content_location = value</span>
            <span class="s0">elif </span><span class="s1">ikey == </span><span class="s3">u&quot;content-length&quot;</span><span class="s1">:</span>
                <span class="s1">content_length = value</span>

        <span class="s2"># make sure the location header is an absolute URL</span>
        <span class="s0">if </span><span class="s1">location </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">old_location = location</span>
            <span class="s0">if </span><span class="s1">isinstance(location, text_type):</span>
                <span class="s2"># Safe conversion is necessary here as we might redirect</span>
                <span class="s2"># to a broken URI scheme (for instance itms-services).</span>
                <span class="s1">location = iri_to_uri(location, safe_conversion=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">self.autocorrect_location_header:</span>
                <span class="s1">current_url = get_current_url(environ, strip_querystring=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">isinstance(current_url, text_type):</span>
                    <span class="s1">current_url = iri_to_uri(current_url)</span>
                <span class="s1">location = url_join(current_url, location)</span>
            <span class="s0">if </span><span class="s1">location != old_location:</span>
                <span class="s1">headers[</span><span class="s3">&quot;Location&quot;</span><span class="s1">] = location</span>

        <span class="s2"># make sure the content location is a URL</span>
        <span class="s0">if </span><span class="s1">content_location </span><span class="s0">is not None and </span><span class="s1">isinstance(content_location, text_type):</span>
            <span class="s1">headers[</span><span class="s3">&quot;Content-Location&quot;</span><span class="s1">] = iri_to_uri(content_location)</span>

        <span class="s0">if </span><span class="s4">100 </span><span class="s1">&lt;= status &lt; </span><span class="s4">200 </span><span class="s0">or </span><span class="s1">status == </span><span class="s4">204</span><span class="s1">:</span>
            <span class="s2"># Per section 3.3.2 of RFC 7230, &quot;a server MUST NOT send a</span>
            <span class="s2"># Content-Length header field in any response with a status</span>
            <span class="s2"># code of 1xx (Informational) or 204 (No Content).&quot;</span>
            <span class="s1">headers.remove(</span><span class="s3">&quot;Content-Length&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">status == </span><span class="s4">304</span><span class="s1">:</span>
            <span class="s1">remove_entity_headers(headers)</span>

        <span class="s2"># if we can determine the content length automatically, we</span>
        <span class="s2"># should try to do that.  But only if this does not involve</span>
        <span class="s2"># flattening the iterator or encoding of unicode strings in</span>
        <span class="s2"># the response.  We however should not do that if we have a 304</span>
        <span class="s2"># response.</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">self.automatically_set_content_length</span>
            <span class="s0">and </span><span class="s1">self.is_sequence</span>
            <span class="s0">and </span><span class="s1">content_length </span><span class="s0">is None</span>
            <span class="s0">and </span><span class="s1">status </span><span class="s0">not in </span><span class="s1">(</span><span class="s4">204</span><span class="s1">, </span><span class="s4">304</span><span class="s1">)</span>
            <span class="s0">and not </span><span class="s1">(</span><span class="s4">100 </span><span class="s1">&lt;= status &lt; </span><span class="s4">200</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">content_length = sum(len(to_bytes(x, </span><span class="s3">&quot;ascii&quot;</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self.response)</span>
            <span class="s0">except </span><span class="s1">UnicodeError:</span>
                <span class="s2"># aha, something non-bytestringy in there, too bad, we</span>
                <span class="s2"># can't safely figure out the length of the response.</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">headers[</span><span class="s3">&quot;Content-Length&quot;</span><span class="s1">] = str(content_length)</span>

        <span class="s0">return </span><span class="s1">headers</span>

    <span class="s0">def </span><span class="s1">get_app_iter(self, environ):</span>
        <span class="s2">&quot;&quot;&quot;Returns the application iterator for the given environ.  Depending 
        on the request method and the current status code the return value 
        might be an empty response rather than the one from the response. 
 
        If the request method is `HEAD` or the status code is in a range 
        where the HTTP specification requires an empty response, an empty 
        iterable is returned. 
 
        .. versionadded:: 0.6 
 
        :param environ: the WSGI environment of the request. 
        :return: a response iterable. 
        &quot;&quot;&quot;</span>
        <span class="s1">status = self.status_code</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">environ[</span><span class="s3">&quot;REQUEST_METHOD&quot;</span><span class="s1">] == </span><span class="s3">&quot;HEAD&quot;</span>
            <span class="s0">or </span><span class="s4">100 </span><span class="s1">&lt;= status &lt; </span><span class="s4">200</span>
            <span class="s0">or </span><span class="s1">status </span><span class="s0">in </span><span class="s1">(</span><span class="s4">204</span><span class="s1">, </span><span class="s4">304</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">iterable = ()</span>
        <span class="s0">elif </span><span class="s1">self.direct_passthrough:</span>
            <span class="s0">if __debug__</span><span class="s1">:</span>
                <span class="s1">_warn_if_string(self.response)</span>
            <span class="s0">return </span><span class="s1">self.response</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">iterable = self.iter_encoded()</span>
        <span class="s0">return </span><span class="s1">ClosingIterator(iterable, self.close)</span>

    <span class="s0">def </span><span class="s1">get_wsgi_response(self, environ):</span>
        <span class="s2">&quot;&quot;&quot;Returns the final WSGI response as tuple.  The first item in 
        the tuple is the application iterator, the second the status and 
        the third the list of headers.  The response returned is created 
        specially for the given environment.  For example if the request 
        method in the WSGI environment is ``'HEAD'`` the response will 
        be empty and only the headers and status code will be present. 
 
        .. versionadded:: 0.6 
 
        :param environ: the WSGI environment of the request. 
        :return: an ``(app_iter, status, headers)`` tuple. 
        &quot;&quot;&quot;</span>
        <span class="s1">headers = self.get_wsgi_headers(environ)</span>
        <span class="s1">app_iter = self.get_app_iter(environ)</span>
        <span class="s0">return </span><span class="s1">app_iter, self.status, headers.to_wsgi_list()</span>

    <span class="s0">def </span><span class="s1">__call__(self, environ, start_response):</span>
        <span class="s2">&quot;&quot;&quot;Process this response as WSGI application. 
 
        :param environ: the WSGI environment. 
        :param start_response: the response callable provided by the WSGI 
                               server. 
        :return: an application iterator 
        &quot;&quot;&quot;</span>
        <span class="s1">app_iter, status, headers = self.get_wsgi_response(environ)</span>
        <span class="s1">start_response(status, headers)</span>
        <span class="s0">return </span><span class="s1">app_iter</span>
</pre>
</body>
</html>