<html>
<head>
<title>app.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #067d17;}
.s4 { color: #0037a6;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
app.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s0">&quot;&quot;&quot; 
    flask.app 
    ~~~~~~~~~ 
 
    This module implements the central WSGI application object. 
 
    :copyright: 2010 Pallets 
    :license: BSD-3-Clause 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">timedelta</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">update_wrapper</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">chain</span>
<span class="s2">from </span><span class="s1">threading </span><span class="s2">import </span><span class="s1">Lock</span>

<span class="s2">from </span><span class="s1">werkzeug.datastructures </span><span class="s2">import </span><span class="s1">Headers</span>
<span class="s2">from </span><span class="s1">werkzeug.datastructures </span><span class="s2">import </span><span class="s1">ImmutableDict</span>
<span class="s2">from </span><span class="s1">werkzeug.exceptions </span><span class="s2">import </span><span class="s1">BadRequest</span>
<span class="s2">from </span><span class="s1">werkzeug.exceptions </span><span class="s2">import </span><span class="s1">BadRequestKeyError</span>
<span class="s2">from </span><span class="s1">werkzeug.exceptions </span><span class="s2">import </span><span class="s1">default_exceptions</span>
<span class="s2">from </span><span class="s1">werkzeug.exceptions </span><span class="s2">import </span><span class="s1">HTTPException</span>
<span class="s2">from </span><span class="s1">werkzeug.exceptions </span><span class="s2">import </span><span class="s1">InternalServerError</span>
<span class="s2">from </span><span class="s1">werkzeug.exceptions </span><span class="s2">import </span><span class="s1">MethodNotAllowed</span>
<span class="s2">from </span><span class="s1">werkzeug.routing </span><span class="s2">import </span><span class="s1">BuildError</span>
<span class="s2">from </span><span class="s1">werkzeug.routing </span><span class="s2">import </span><span class="s1">Map</span>
<span class="s2">from </span><span class="s1">werkzeug.routing </span><span class="s2">import </span><span class="s1">RequestRedirect</span>
<span class="s2">from </span><span class="s1">werkzeug.routing </span><span class="s2">import </span><span class="s1">RoutingException</span>
<span class="s2">from </span><span class="s1">werkzeug.routing </span><span class="s2">import </span><span class="s1">Rule</span>
<span class="s2">from </span><span class="s1">werkzeug.wrappers </span><span class="s2">import </span><span class="s1">BaseResponse</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">cli</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">json</span>
<span class="s2">from </span><span class="s1">._compat </span><span class="s2">import </span><span class="s1">integer_types</span>
<span class="s2">from </span><span class="s1">._compat </span><span class="s2">import </span><span class="s1">reraise</span>
<span class="s2">from </span><span class="s1">._compat </span><span class="s2">import </span><span class="s1">string_types</span>
<span class="s2">from </span><span class="s1">._compat </span><span class="s2">import </span><span class="s1">text_type</span>
<span class="s2">from </span><span class="s1">.config </span><span class="s2">import </span><span class="s1">Config</span>
<span class="s2">from </span><span class="s1">.config </span><span class="s2">import </span><span class="s1">ConfigAttribute</span>
<span class="s2">from </span><span class="s1">.ctx </span><span class="s2">import </span><span class="s1">_AppCtxGlobals</span>
<span class="s2">from </span><span class="s1">.ctx </span><span class="s2">import </span><span class="s1">AppContext</span>
<span class="s2">from </span><span class="s1">.ctx </span><span class="s2">import </span><span class="s1">RequestContext</span>
<span class="s2">from </span><span class="s1">.globals </span><span class="s2">import </span><span class="s1">_request_ctx_stack</span>
<span class="s2">from </span><span class="s1">.globals </span><span class="s2">import </span><span class="s1">g</span>
<span class="s2">from </span><span class="s1">.globals </span><span class="s2">import </span><span class="s1">request</span>
<span class="s2">from </span><span class="s1">.globals </span><span class="s2">import </span><span class="s1">session</span>
<span class="s2">from </span><span class="s1">.helpers </span><span class="s2">import </span><span class="s1">_endpoint_from_view_func</span>
<span class="s2">from </span><span class="s1">.helpers </span><span class="s2">import </span><span class="s1">_PackageBoundObject</span>
<span class="s2">from </span><span class="s1">.helpers </span><span class="s2">import </span><span class="s1">find_package</span>
<span class="s2">from </span><span class="s1">.helpers </span><span class="s2">import </span><span class="s1">get_debug_flag</span>
<span class="s2">from </span><span class="s1">.helpers </span><span class="s2">import </span><span class="s1">get_env</span>
<span class="s2">from </span><span class="s1">.helpers </span><span class="s2">import </span><span class="s1">get_flashed_messages</span>
<span class="s2">from </span><span class="s1">.helpers </span><span class="s2">import </span><span class="s1">get_load_dotenv</span>
<span class="s2">from </span><span class="s1">.helpers </span><span class="s2">import </span><span class="s1">locked_cached_property</span>
<span class="s2">from </span><span class="s1">.helpers </span><span class="s2">import </span><span class="s1">url_for</span>
<span class="s2">from </span><span class="s1">.json </span><span class="s2">import </span><span class="s1">jsonify</span>
<span class="s2">from </span><span class="s1">.logging </span><span class="s2">import </span><span class="s1">create_logger</span>
<span class="s2">from </span><span class="s1">.sessions </span><span class="s2">import </span><span class="s1">SecureCookieSessionInterface</span>
<span class="s2">from </span><span class="s1">.signals </span><span class="s2">import </span><span class="s1">appcontext_tearing_down</span>
<span class="s2">from </span><span class="s1">.signals </span><span class="s2">import </span><span class="s1">got_request_exception</span>
<span class="s2">from </span><span class="s1">.signals </span><span class="s2">import </span><span class="s1">request_finished</span>
<span class="s2">from </span><span class="s1">.signals </span><span class="s2">import </span><span class="s1">request_started</span>
<span class="s2">from </span><span class="s1">.signals </span><span class="s2">import </span><span class="s1">request_tearing_down</span>
<span class="s2">from </span><span class="s1">.templating </span><span class="s2">import </span><span class="s1">_default_template_ctx_processor</span>
<span class="s2">from </span><span class="s1">.templating </span><span class="s2">import </span><span class="s1">DispatchingJinjaLoader</span>
<span class="s2">from </span><span class="s1">.templating </span><span class="s2">import </span><span class="s1">Environment</span>
<span class="s2">from </span><span class="s1">.wrappers </span><span class="s2">import </span><span class="s1">Request</span>
<span class="s2">from </span><span class="s1">.wrappers </span><span class="s2">import </span><span class="s1">Response</span>

<span class="s0"># a singleton sentinel value for parameter defaults</span>
<span class="s1">_sentinel = object()</span>


<span class="s2">def </span><span class="s1">_make_timedelta(value):</span>
    <span class="s2">if not </span><span class="s1">isinstance(value, timedelta):</span>
        <span class="s2">return </span><span class="s1">timedelta(seconds=value)</span>
    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">setupmethod(f):</span>
    <span class="s0">&quot;&quot;&quot;Wraps a method so that it performs a check in debug mode if the 
    first request was already handled. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">wrapper_func(self, *args, **kwargs):</span>
        <span class="s2">if </span><span class="s1">self.debug </span><span class="s2">and </span><span class="s1">self._got_first_request:</span>
            <span class="s2">raise </span><span class="s1">AssertionError(</span>
                <span class="s3">&quot;A setup function was called after the &quot;</span>
                <span class="s3">&quot;first request was handled.  This usually indicates a bug &quot;</span>
                <span class="s3">&quot;in the application where a module was not imported &quot;</span>
                <span class="s3">&quot;and decorators or other functionality was called too late.</span><span class="s4">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;To fix this make sure to import all your view modules, &quot;</span>
                <span class="s3">&quot;database models and everything related at a central place &quot;</span>
                <span class="s3">&quot;before the application starts serving requests.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">f(self, *args, **kwargs)</span>

    <span class="s2">return </span><span class="s1">update_wrapper(wrapper_func, f)</span>


<span class="s2">class </span><span class="s1">Flask(_PackageBoundObject):</span>
    <span class="s0">&quot;&quot;&quot;The flask object implements a WSGI application and acts as the central 
    object.  It is passed the name of the module or package of the 
    application.  Once it is created it will act as a central registry for 
    the view functions, the URL rules, template configuration and much more. 
 
    The name of the package is used to resolve resources from inside the 
    package or the folder the module is contained in depending on if the 
    package parameter resolves to an actual python package (a folder with 
    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file). 
 
    For more information about resource loading, see :func:`open_resource`. 
 
    Usually you create a :class:`Flask` instance in your main module or 
    in the :file:`__init__.py` file of your package like this:: 
 
        from flask import Flask 
        app = Flask(__name__) 
 
    .. admonition:: About the First Parameter 
 
        The idea of the first parameter is to give Flask an idea of what 
        belongs to your application.  This name is used to find resources 
        on the filesystem, can be used by extensions to improve debugging 
        information and a lot more. 
 
        So it's important what you provide there.  If you are using a single 
        module, `__name__` is always the correct value.  If you however are 
        using a package, it's usually recommended to hardcode the name of 
        your package there. 
 
        For example if your application is defined in :file:`yourapplication/app.py` 
        you should create it with one of the two versions below:: 
 
            app = Flask('yourapplication') 
            app = Flask(__name__.split('.')[0]) 
 
        Why is that?  The application will work even with `__name__`, thanks 
        to how resources are looked up.  However it will make debugging more 
        painful.  Certain extensions can make assumptions based on the 
        import name of your application.  For example the Flask-SQLAlchemy 
        extension will look for the code in your application that triggered 
        an SQL query in debug mode.  If the import name is not properly set 
        up, that debugging information is lost.  (For example it would only 
        pick up SQL queries in `yourapplication.app` and not 
        `yourapplication.views.frontend`) 
 
    .. versionadded:: 0.7 
       The `static_url_path`, `static_folder`, and `template_folder` 
       parameters were added. 
 
    .. versionadded:: 0.8 
       The `instance_path` and `instance_relative_config` parameters were 
       added. 
 
    .. versionadded:: 0.11 
       The `root_path` parameter was added. 
 
    .. versionadded:: 1.0 
       The ``host_matching`` and ``static_host`` parameters were added. 
 
    .. versionadded:: 1.0 
       The ``subdomain_matching`` parameter was added. Subdomain 
       matching needs to be enabled manually now. Setting 
       :data:`SERVER_NAME` does not implicitly enable it. 
 
    :param import_name: the name of the application package 
    :param static_url_path: can be used to specify a different path for the 
                            static files on the web.  Defaults to the name 
                            of the `static_folder` folder. 
    :param static_folder: The folder with static files that is served at 
        ``static_url_path``. Relative to the application ``root_path`` 
        or an absolute path. Defaults to ``'static'``. 
    :param static_host: the host to use when adding the static route. 
        Defaults to None. Required when using ``host_matching=True`` 
        with a ``static_folder`` configured. 
    :param host_matching: set ``url_map.host_matching`` attribute. 
        Defaults to False. 
    :param subdomain_matching: consider the subdomain relative to 
        :data:`SERVER_NAME` when matching routes. Defaults to False. 
    :param template_folder: the folder that contains the templates that should 
                            be used by the application.  Defaults to 
                            ``'templates'`` folder in the root path of the 
                            application. 
    :param instance_path: An alternative instance path for the application. 
                          By default the folder ``'instance'`` next to the 
                          package or module is assumed to be the instance 
                          path. 
    :param instance_relative_config: if set to ``True`` relative filenames 
                                     for loading the config are assumed to 
                                     be relative to the instance path instead 
                                     of the application root. 
    :param root_path: Flask by default will automatically calculate the path 
                      to the root of the application.  In certain situations 
                      this cannot be achieved (for instance if the package 
                      is a Python 3 namespace package) and needs to be 
                      manually defined. 
    &quot;&quot;&quot;</span>

    <span class="s0">#: The class that is used for request objects.  See :class:`~flask.Request`</span>
    <span class="s0">#: for more information.</span>
    <span class="s1">request_class = Request</span>

    <span class="s0">#: The class that is used for response objects.  See</span>
    <span class="s0">#: :class:`~flask.Response` for more information.</span>
    <span class="s1">response_class = Response</span>

    <span class="s0">#: The class that is used for the Jinja environment.</span>
    <span class="s0">#:</span>
    <span class="s0">#: .. versionadded:: 0.11</span>
    <span class="s1">jinja_environment = Environment</span>

    <span class="s0">#: The class that is used for the :data:`~flask.g` instance.</span>
    <span class="s0">#:</span>
    <span class="s0">#: Example use cases for a custom class:</span>
    <span class="s0">#:</span>
    <span class="s0">#: 1. Store arbitrary attributes on flask.g.</span>
    <span class="s0">#: 2. Add a property for lazy per-request database connectors.</span>
    <span class="s0">#: 3. Return None instead of AttributeError on unexpected attributes.</span>
    <span class="s0">#: 4. Raise exception if an unexpected attr is set, a &quot;controlled&quot; flask.g.</span>
    <span class="s0">#:</span>
    <span class="s0">#: In Flask 0.9 this property was called `request_globals_class` but it</span>
    <span class="s0">#: was changed in 0.10 to :attr:`app_ctx_globals_class` because the</span>
    <span class="s0">#: flask.g object is now application context scoped.</span>
    <span class="s0">#:</span>
    <span class="s0">#: .. versionadded:: 0.10</span>
    <span class="s1">app_ctx_globals_class = _AppCtxGlobals</span>

    <span class="s0">#: The class that is used for the ``config`` attribute of this app.</span>
    <span class="s0">#: Defaults to :class:`~flask.Config`.</span>
    <span class="s0">#:</span>
    <span class="s0">#: Example use cases for a custom class:</span>
    <span class="s0">#:</span>
    <span class="s0">#: 1. Default values for certain config options.</span>
    <span class="s0">#: 2. Access to config values through attributes in addition to keys.</span>
    <span class="s0">#:</span>
    <span class="s0">#: .. versionadded:: 0.11</span>
    <span class="s1">config_class = Config</span>

    <span class="s0">#: The testing flag.  Set this to ``True`` to enable the test mode of</span>
    <span class="s0">#: Flask extensions (and in the future probably also Flask itself).</span>
    <span class="s0">#: For example this might activate test helpers that have an</span>
    <span class="s0">#: additional runtime cost which should not be enabled by default.</span>
    <span class="s0">#:</span>
    <span class="s0">#: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the</span>
    <span class="s0">#: default it's implicitly enabled.</span>
    <span class="s0">#:</span>
    <span class="s0">#: This attribute can also be configured from the config with the</span>
    <span class="s0">#: ``TESTING`` configuration key.  Defaults to ``False``.</span>
    <span class="s1">testing = ConfigAttribute(</span><span class="s3">&quot;TESTING&quot;</span><span class="s1">)</span>

    <span class="s0">#: If a secret key is set, cryptographic components can use this to</span>
    <span class="s0">#: sign cookies and other things. Set this to a complex random value</span>
    <span class="s0">#: when you want to use the secure cookie for instance.</span>
    <span class="s0">#:</span>
    <span class="s0">#: This attribute can also be configured from the config with the</span>
    <span class="s0">#: :data:`SECRET_KEY` configuration key. Defaults to ``None``.</span>
    <span class="s1">secret_key = ConfigAttribute(</span><span class="s3">&quot;SECRET_KEY&quot;</span><span class="s1">)</span>

    <span class="s0">#: The secure cookie uses this for the name of the session cookie.</span>
    <span class="s0">#:</span>
    <span class="s0">#: This attribute can also be configured from the config with the</span>
    <span class="s0">#: ``SESSION_COOKIE_NAME`` configuration key.  Defaults to ``'session'``</span>
    <span class="s1">session_cookie_name = ConfigAttribute(</span><span class="s3">&quot;SESSION_COOKIE_NAME&quot;</span><span class="s1">)</span>

    <span class="s0">#: A :class:`~datetime.timedelta` which is used to set the expiration</span>
    <span class="s0">#: date of a permanent session.  The default is 31 days which makes a</span>
    <span class="s0">#: permanent session survive for roughly one month.</span>
    <span class="s0">#:</span>
    <span class="s0">#: This attribute can also be configured from the config with the</span>
    <span class="s0">#: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to</span>
    <span class="s0">#: ``timedelta(days=31)``</span>
    <span class="s1">permanent_session_lifetime = ConfigAttribute(</span>
        <span class="s3">&quot;PERMANENT_SESSION_LIFETIME&quot;</span><span class="s1">, get_converter=_make_timedelta</span>
    <span class="s1">)</span>

    <span class="s0">#: A :class:`~datetime.timedelta` which is used as default cache_timeout</span>
    <span class="s0">#: for the :func:`send_file` functions. The default is 12 hours.</span>
    <span class="s0">#:</span>
    <span class="s0">#: This attribute can also be configured from the config with the</span>
    <span class="s0">#: ``SEND_FILE_MAX_AGE_DEFAULT`` configuration key. This configuration</span>
    <span class="s0">#: variable can also be set with an integer value used as seconds.</span>
    <span class="s0">#: Defaults to ``timedelta(hours=12)``</span>
    <span class="s1">send_file_max_age_default = ConfigAttribute(</span>
        <span class="s3">&quot;SEND_FILE_MAX_AGE_DEFAULT&quot;</span><span class="s1">, get_converter=_make_timedelta</span>
    <span class="s1">)</span>

    <span class="s0">#: Enable this if you want to use the X-Sendfile feature.  Keep in</span>
    <span class="s0">#: mind that the server has to support this.  This only affects files</span>
    <span class="s0">#: sent with the :func:`send_file` method.</span>
    <span class="s0">#:</span>
    <span class="s0">#: .. versionadded:: 0.2</span>
    <span class="s0">#:</span>
    <span class="s0">#: This attribute can also be configured from the config with the</span>
    <span class="s0">#: ``USE_X_SENDFILE`` configuration key.  Defaults to ``False``.</span>
    <span class="s1">use_x_sendfile = ConfigAttribute(</span><span class="s3">&quot;USE_X_SENDFILE&quot;</span><span class="s1">)</span>

    <span class="s0">#: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.</span>
    <span class="s0">#:</span>
    <span class="s0">#: .. versionadded:: 0.10</span>
    <span class="s1">json_encoder = json.JSONEncoder</span>

    <span class="s0">#: The JSON decoder class to use.  Defaults to :class:`~flask.json.JSONDecoder`.</span>
    <span class="s0">#:</span>
    <span class="s0">#: .. versionadded:: 0.10</span>
    <span class="s1">json_decoder = json.JSONDecoder</span>

    <span class="s0">#: Options that are passed to the Jinja environment in</span>
    <span class="s0">#: :meth:`create_jinja_environment`. Changing these options after</span>
    <span class="s0">#: the environment is created (accessing :attr:`jinja_env`) will</span>
    <span class="s0">#: have no effect.</span>
    <span class="s0">#:</span>
    <span class="s0">#: .. versionchanged:: 1.1.0</span>
    <span class="s0">#:     This is a ``dict`` instead of an ``ImmutableDict`` to allow</span>
    <span class="s0">#:     easier configuration.</span>
    <span class="s0">#:</span>
    <span class="s1">jinja_options = {</span><span class="s3">&quot;extensions&quot;</span><span class="s1">: [</span><span class="s3">&quot;jinja2.ext.autoescape&quot;</span><span class="s1">, </span><span class="s3">&quot;jinja2.ext.with_&quot;</span><span class="s1">]}</span>

    <span class="s0">#: Default configuration parameters.</span>
    <span class="s1">default_config = ImmutableDict(</span>
        <span class="s1">{</span>
            <span class="s3">&quot;ENV&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">,</span>
            <span class="s3">&quot;DEBUG&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">,</span>
            <span class="s3">&quot;TESTING&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s1">,</span>
            <span class="s3">&quot;PROPAGATE_EXCEPTIONS&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">,</span>
            <span class="s3">&quot;PRESERVE_CONTEXT_ON_EXCEPTION&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">,</span>
            <span class="s3">&quot;SECRET_KEY&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">,</span>
            <span class="s3">&quot;PERMANENT_SESSION_LIFETIME&quot;</span><span class="s1">: timedelta(days=</span><span class="s5">31</span><span class="s1">),</span>
            <span class="s3">&quot;USE_X_SENDFILE&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s1">,</span>
            <span class="s3">&quot;SERVER_NAME&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">,</span>
            <span class="s3">&quot;APPLICATION_ROOT&quot;</span><span class="s1">: </span><span class="s3">&quot;/&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;SESSION_COOKIE_NAME&quot;</span><span class="s1">: </span><span class="s3">&quot;session&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;SESSION_COOKIE_DOMAIN&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">,</span>
            <span class="s3">&quot;SESSION_COOKIE_PATH&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">,</span>
            <span class="s3">&quot;SESSION_COOKIE_HTTPONLY&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">,</span>
            <span class="s3">&quot;SESSION_COOKIE_SECURE&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s1">,</span>
            <span class="s3">&quot;SESSION_COOKIE_SAMESITE&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">,</span>
            <span class="s3">&quot;SESSION_REFRESH_EACH_REQUEST&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">,</span>
            <span class="s3">&quot;MAX_CONTENT_LENGTH&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">,</span>
            <span class="s3">&quot;SEND_FILE_MAX_AGE_DEFAULT&quot;</span><span class="s1">: timedelta(hours=</span><span class="s5">12</span><span class="s1">),</span>
            <span class="s3">&quot;TRAP_BAD_REQUEST_ERRORS&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">,</span>
            <span class="s3">&quot;TRAP_HTTP_EXCEPTIONS&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s1">,</span>
            <span class="s3">&quot;EXPLAIN_TEMPLATE_LOADING&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s1">,</span>
            <span class="s3">&quot;PREFERRED_URL_SCHEME&quot;</span><span class="s1">: </span><span class="s3">&quot;http&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;JSON_AS_ASCII&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">,</span>
            <span class="s3">&quot;JSON_SORT_KEYS&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">,</span>
            <span class="s3">&quot;JSONIFY_PRETTYPRINT_REGULAR&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s1">,</span>
            <span class="s3">&quot;JSONIFY_MIMETYPE&quot;</span><span class="s1">: </span><span class="s3">&quot;application/json&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;TEMPLATES_AUTO_RELOAD&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">,</span>
            <span class="s3">&quot;MAX_COOKIE_SIZE&quot;</span><span class="s1">: </span><span class="s5">4093</span><span class="s1">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>

    <span class="s0">#: The rule object to use for URL rules created.  This is used by</span>
    <span class="s0">#: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.</span>
    <span class="s0">#:</span>
    <span class="s0">#: .. versionadded:: 0.7</span>
    <span class="s1">url_rule_class = Rule</span>

    <span class="s0">#: The map object to use for storing the URL rules and routing</span>
    <span class="s0">#: configuration parameters. Defaults to :class:`werkzeug.routing.Map`.</span>
    <span class="s0">#:</span>
    <span class="s0">#: .. versionadded:: 1.1.0</span>
    <span class="s1">url_map_class = Map</span>

    <span class="s0">#: the test client that is used with when `test_client` is used.</span>
    <span class="s0">#:</span>
    <span class="s0">#: .. versionadded:: 0.7</span>
    <span class="s1">test_client_class = </span><span class="s2">None</span>

    <span class="s0">#: The :class:`~click.testing.CliRunner` subclass, by default</span>
    <span class="s0">#: :class:`~flask.testing.FlaskCliRunner` that is used by</span>
    <span class="s0">#: :meth:`test_cli_runner`. Its ``__init__`` method should take a</span>
    <span class="s0">#: Flask app object as the first argument.</span>
    <span class="s0">#:</span>
    <span class="s0">#: .. versionadded:: 1.0</span>
    <span class="s1">test_cli_runner_class = </span><span class="s2">None</span>

    <span class="s0">#: the session interface to use.  By default an instance of</span>
    <span class="s0">#: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.</span>
    <span class="s0">#:</span>
    <span class="s0">#: .. versionadded:: 0.8</span>
    <span class="s1">session_interface = SecureCookieSessionInterface()</span>

    <span class="s0"># TODO remove the next three attrs when Sphinx :inherited-members: works</span>
    <span class="s0"># https://github.com/sphinx-doc/sphinx/issues/741</span>

    <span class="s0">#: The name of the package or module that this app belongs to. Do not</span>
    <span class="s0">#: change this once it is set by the constructor.</span>
    <span class="s1">import_name = </span><span class="s2">None</span>

    <span class="s0">#: Location of the template files to be added to the template lookup.</span>
    <span class="s0">#: ``None`` if templates should not be added.</span>
    <span class="s1">template_folder = </span><span class="s2">None</span>

    <span class="s0">#: Absolute path to the package on the filesystem. Used to look up</span>
    <span class="s0">#: resources contained in the package.</span>
    <span class="s1">root_path = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">import_name,</span>
        <span class="s1">static_url_path=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">static_folder=</span><span class="s3">&quot;static&quot;</span><span class="s1">,</span>
        <span class="s1">static_host=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">host_matching=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">subdomain_matching=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">template_folder=</span><span class="s3">&quot;templates&quot;</span><span class="s1">,</span>
        <span class="s1">instance_path=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">instance_relative_config=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">root_path=</span><span class="s2">None</span><span class="s1">,</span>
    <span class="s1">):</span>
        <span class="s1">_PackageBoundObject.__init__(</span>
            <span class="s1">self, import_name, template_folder=template_folder, root_path=root_path</span>
        <span class="s1">)</span>

        <span class="s1">self.static_url_path = static_url_path</span>
        <span class="s1">self.static_folder = static_folder</span>

        <span class="s2">if </span><span class="s1">instance_path </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">instance_path = self.auto_find_instance_path()</span>
        <span class="s2">elif not </span><span class="s1">os.path.isabs(instance_path):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;If an instance path is provided it must be absolute.&quot;</span>
                <span class="s3">&quot; A relative path was given instead.&quot;</span>
            <span class="s1">)</span>

        <span class="s0">#: Holds the path to the instance folder.</span>
        <span class="s0">#:</span>
        <span class="s0">#: .. versionadded:: 0.8</span>
        <span class="s1">self.instance_path = instance_path</span>

        <span class="s0">#: The configuration dictionary as :class:`Config`.  This behaves</span>
        <span class="s0">#: exactly like a regular dictionary but supports additional methods</span>
        <span class="s0">#: to load a config from files.</span>
        <span class="s1">self.config = self.make_config(instance_relative_config)</span>

        <span class="s0">#: A dictionary of all view functions registered.  The keys will</span>
        <span class="s0">#: be function names which are also used to generate URLs and</span>
        <span class="s0">#: the values are the function objects themselves.</span>
        <span class="s0">#: To register a view function, use the :meth:`route` decorator.</span>
        <span class="s1">self.view_functions = {}</span>

        <span class="s0">#: A dictionary of all registered error handlers.  The key is ``None``</span>
        <span class="s0">#: for error handlers active on the application, otherwise the key is</span>
        <span class="s0">#: the name of the blueprint.  Each key points to another dictionary</span>
        <span class="s0">#: where the key is the status code of the http exception.  The</span>
        <span class="s0">#: special key ``None`` points to a list of tuples where the first item</span>
        <span class="s0">#: is the class for the instance check and the second the error handler</span>
        <span class="s0">#: function.</span>
        <span class="s0">#:</span>
        <span class="s0">#: To register an error handler, use the :meth:`errorhandler`</span>
        <span class="s0">#: decorator.</span>
        <span class="s1">self.error_handler_spec = {}</span>

        <span class="s0">#: A list of functions that are called when :meth:`url_for` raises a</span>
        <span class="s0">#: :exc:`~werkzeug.routing.BuildError`.  Each function registered here</span>
        <span class="s0">#: is called with `error`, `endpoint` and `values`.  If a function</span>
        <span class="s0">#: returns ``None`` or raises a :exc:`BuildError` the next function is</span>
        <span class="s0">#: tried.</span>
        <span class="s0">#:</span>
        <span class="s0">#: .. versionadded:: 0.9</span>
        <span class="s1">self.url_build_error_handlers = []</span>

        <span class="s0">#: A dictionary with lists of functions that will be called at the</span>
        <span class="s0">#: beginning of each request. The key of the dictionary is the name of</span>
        <span class="s0">#: the blueprint this function is active for, or ``None`` for all</span>
        <span class="s0">#: requests. To register a function, use the :meth:`before_request`</span>
        <span class="s0">#: decorator.</span>
        <span class="s1">self.before_request_funcs = {}</span>

        <span class="s0">#: A list of functions that will be called at the beginning of the</span>
        <span class="s0">#: first request to this instance. To register a function, use the</span>
        <span class="s0">#: :meth:`before_first_request` decorator.</span>
        <span class="s0">#:</span>
        <span class="s0">#: .. versionadded:: 0.8</span>
        <span class="s1">self.before_first_request_funcs = []</span>

        <span class="s0">#: A dictionary with lists of functions that should be called after</span>
        <span class="s0">#: each request.  The key of the dictionary is the name of the blueprint</span>
        <span class="s0">#: this function is active for, ``None`` for all requests.  This can for</span>
        <span class="s0">#: example be used to close database connections. To register a function</span>
        <span class="s0">#: here, use the :meth:`after_request` decorator.</span>
        <span class="s1">self.after_request_funcs = {}</span>

        <span class="s0">#: A dictionary with lists of functions that are called after</span>
        <span class="s0">#: each request, even if an exception has occurred. The key of the</span>
        <span class="s0">#: dictionary is the name of the blueprint this function is active for,</span>
        <span class="s0">#: ``None`` for all requests. These functions are not allowed to modify</span>
        <span class="s0">#: the request, and their return values are ignored. If an exception</span>
        <span class="s0">#: occurred while processing the request, it gets passed to each</span>
        <span class="s0">#: teardown_request function. To register a function here, use the</span>
        <span class="s0">#: :meth:`teardown_request` decorator.</span>
        <span class="s0">#:</span>
        <span class="s0">#: .. versionadded:: 0.7</span>
        <span class="s1">self.teardown_request_funcs = {}</span>

        <span class="s0">#: A list of functions that are called when the application context</span>
        <span class="s0">#: is destroyed.  Since the application context is also torn down</span>
        <span class="s0">#: if the request ends this is the place to store code that disconnects</span>
        <span class="s0">#: from databases.</span>
        <span class="s0">#:</span>
        <span class="s0">#: .. versionadded:: 0.9</span>
        <span class="s1">self.teardown_appcontext_funcs = []</span>

        <span class="s0">#: A dictionary with lists of functions that are called before the</span>
        <span class="s0">#: :attr:`before_request_funcs` functions. The key of the dictionary is</span>
        <span class="s0">#: the name of the blueprint this function is active for, or ``None``</span>
        <span class="s0">#: for all requests. To register a function, use</span>
        <span class="s0">#: :meth:`url_value_preprocessor`.</span>
        <span class="s0">#:</span>
        <span class="s0">#: .. versionadded:: 0.7</span>
        <span class="s1">self.url_value_preprocessors = {}</span>

        <span class="s0">#: A dictionary with lists of functions that can be used as URL value</span>
        <span class="s0">#: preprocessors.  The key ``None`` here is used for application wide</span>
        <span class="s0">#: callbacks, otherwise the key is the name of the blueprint.</span>
        <span class="s0">#: Each of these functions has the chance to modify the dictionary</span>
        <span class="s0">#: of URL values before they are used as the keyword arguments of the</span>
        <span class="s0">#: view function.  For each function registered this one should also</span>
        <span class="s0">#: provide a :meth:`url_defaults` function that adds the parameters</span>
        <span class="s0">#: automatically again that were removed that way.</span>
        <span class="s0">#:</span>
        <span class="s0">#: .. versionadded:: 0.7</span>
        <span class="s1">self.url_default_functions = {}</span>

        <span class="s0">#: A dictionary with list of functions that are called without argument</span>
        <span class="s0">#: to populate the template context.  The key of the dictionary is the</span>
        <span class="s0">#: name of the blueprint this function is active for, ``None`` for all</span>
        <span class="s0">#: requests.  Each returns a dictionary that the template context is</span>
        <span class="s0">#: updated with.  To register a function here, use the</span>
        <span class="s0">#: :meth:`context_processor` decorator.</span>
        <span class="s1">self.template_context_processors = {</span><span class="s2">None</span><span class="s1">: [_default_template_ctx_processor]}</span>

        <span class="s0">#: A list of shell context processor functions that should be run</span>
        <span class="s0">#: when a shell context is created.</span>
        <span class="s0">#:</span>
        <span class="s0">#: .. versionadded:: 0.11</span>
        <span class="s1">self.shell_context_processors = []</span>

        <span class="s0">#: all the attached blueprints in a dictionary by name.  Blueprints</span>
        <span class="s0">#: can be attached multiple times so this dictionary does not tell</span>
        <span class="s0">#: you how often they got attached.</span>
        <span class="s0">#:</span>
        <span class="s0">#: .. versionadded:: 0.7</span>
        <span class="s1">self.blueprints = {}</span>
        <span class="s1">self._blueprint_order = []</span>

        <span class="s0">#: a place where extensions can store application specific state.  For</span>
        <span class="s0">#: example this is where an extension could store database engines and</span>
        <span class="s0">#: similar things.  For backwards compatibility extensions should register</span>
        <span class="s0">#: themselves like this::</span>
        <span class="s0">#:</span>
        <span class="s0">#:      if not hasattr(app, 'extensions'):</span>
        <span class="s0">#:          app.extensions = {}</span>
        <span class="s0">#:      app.extensions['extensionname'] = SomeObject()</span>
        <span class="s0">#:</span>
        <span class="s0">#: The key must match the name of the extension module. For example in</span>
        <span class="s0">#: case of a &quot;Flask-Foo&quot; extension in `flask_foo`, the key would be</span>
        <span class="s0">#: ``'foo'``.</span>
        <span class="s0">#:</span>
        <span class="s0">#: .. versionadded:: 0.7</span>
        <span class="s1">self.extensions = {}</span>

        <span class="s0">#: The :class:`~werkzeug.routing.Map` for this instance.  You can use</span>
        <span class="s0">#: this to change the routing converters after the class was created</span>
        <span class="s0">#: but before any routes are connected.  Example::</span>
        <span class="s0">#:</span>
        <span class="s0">#:    from werkzeug.routing import BaseConverter</span>
        <span class="s0">#:</span>
        <span class="s0">#:    class ListConverter(BaseConverter):</span>
        <span class="s0">#:        def to_python(self, value):</span>
        <span class="s0">#:            return value.split(',')</span>
        <span class="s0">#:        def to_url(self, values):</span>
        <span class="s0">#:            return ','.join(super(ListConverter, self).to_url(value)</span>
        <span class="s0">#:                            for value in values)</span>
        <span class="s0">#:</span>
        <span class="s0">#:    app = Flask(__name__)</span>
        <span class="s0">#:    app.url_map.converters['list'] = ListConverter</span>
        <span class="s1">self.url_map = self.url_map_class()</span>

        <span class="s1">self.url_map.host_matching = host_matching</span>
        <span class="s1">self.subdomain_matching = subdomain_matching</span>

        <span class="s0"># tracks internally if the application already handled at least one</span>
        <span class="s0"># request.</span>
        <span class="s1">self._got_first_request = </span><span class="s2">False</span>
        <span class="s1">self._before_request_lock = Lock()</span>

        <span class="s0"># Add a static route using the provided static_url_path, static_host,</span>
        <span class="s0"># and static_folder if there is a configured static_folder.</span>
        <span class="s0"># Note we do this without checking if static_folder exists.</span>
        <span class="s0"># For one, it might be created while the server is running (e.g. during</span>
        <span class="s0"># development). Also, Google App Engine stores static files somewhere</span>
        <span class="s2">if </span><span class="s1">self.has_static_folder:</span>
            <span class="s2">assert </span><span class="s1">(</span>
                <span class="s1">bool(static_host) == host_matching</span>
            <span class="s1">), </span><span class="s3">&quot;Invalid static_host/host_matching combination&quot;</span>
            <span class="s1">self.add_url_rule(</span>
                <span class="s1">self.static_url_path + </span><span class="s3">&quot;/&lt;path:filename&gt;&quot;</span><span class="s1">,</span>
                <span class="s1">endpoint=</span><span class="s3">&quot;static&quot;</span><span class="s1">,</span>
                <span class="s1">host=static_host,</span>
                <span class="s1">view_func=self.send_static_file,</span>
            <span class="s1">)</span>

        <span class="s0"># Set the name of the Click group in case someone wants to add</span>
        <span class="s0"># the app's commands to another CLI tool.</span>
        <span class="s1">self.cli.name = self.name</span>

    <span class="s1">@locked_cached_property</span>
    <span class="s2">def </span><span class="s1">name(self):</span>
        <span class="s0">&quot;&quot;&quot;The name of the application.  This is usually the import name 
        with the difference that it's guessed from the run file if the 
        import name is main.  This name is used as a display name when 
        Flask needs the name of the application.  It can be set and overridden 
        to change the value. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.import_name == </span><span class="s3">&quot;__main__&quot;</span><span class="s1">:</span>
            <span class="s1">fn = getattr(sys.modules[</span><span class="s3">&quot;__main__&quot;</span><span class="s1">], </span><span class="s3">&quot;__file__&quot;</span><span class="s1">, </span><span class="s2">None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">fn </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s3">&quot;__main__&quot;</span>
            <span class="s2">return </span><span class="s1">os.path.splitext(os.path.basename(fn))[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">self.import_name</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">propagate_exceptions(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration 
        value in case it's set, otherwise a sensible default is returned. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = self.config[</span><span class="s3">&quot;PROPAGATE_EXCEPTIONS&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">rv </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">rv</span>
        <span class="s2">return </span><span class="s1">self.testing </span><span class="s2">or </span><span class="s1">self.debug</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">preserve_context_on_exception(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns the value of the ``PRESERVE_CONTEXT_ON_EXCEPTION`` 
        configuration value in case it's set, otherwise a sensible default 
        is returned. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = self.config[</span><span class="s3">&quot;PRESERVE_CONTEXT_ON_EXCEPTION&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">rv </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">rv</span>
        <span class="s2">return </span><span class="s1">self.debug</span>

    <span class="s1">@locked_cached_property</span>
    <span class="s2">def </span><span class="s1">logger(self):</span>
        <span class="s0">&quot;&quot;&quot;A standard Python :class:`~logging.Logger` for the app, with 
        the same name as :attr:`name`. 
 
        In debug mode, the logger's :attr:`~logging.Logger.level` will 
        be set to :data:`~logging.DEBUG`. 
 
        If there are no handlers configured, a default handler will be 
        added. See :doc:`/logging` for more information. 
 
        .. versionchanged:: 1.1.0 
            The logger takes the same name as :attr:`name` rather than 
            hard-coding ``&quot;flask.app&quot;``. 
 
        .. versionchanged:: 1.0.0 
            Behavior was simplified. The logger is always named 
            ``&quot;flask.app&quot;``. The level is only set during configuration, 
            it doesn't check ``app.debug`` each time. Only one format is 
            used, not different ones depending on ``app.debug``. No 
            handlers are removed, and a handler is only added if no 
            handlers are already configured. 
 
        .. versionadded:: 0.3 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">create_logger(self)</span>

    <span class="s1">@locked_cached_property</span>
    <span class="s2">def </span><span class="s1">jinja_env(self):</span>
        <span class="s0">&quot;&quot;&quot;The Jinja environment used to load templates. 
 
        The environment is created the first time this property is 
        accessed. Changing :attr:`jinja_options` after that will have no 
        effect. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.create_jinja_environment()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">got_first_request(self):</span>
        <span class="s0">&quot;&quot;&quot;This attribute is set to ``True`` if the application started 
        handling the first request. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._got_first_request</span>

    <span class="s2">def </span><span class="s1">make_config(self, instance_relative=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Used to create the config attribute by the Flask constructor. 
        The `instance_relative` parameter is passed in from the constructor 
        of Flask (there named `instance_relative_config`) and indicates if 
        the config should be relative to the instance path or the root path 
        of the application. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s1">root_path = self.root_path</span>
        <span class="s2">if </span><span class="s1">instance_relative:</span>
            <span class="s1">root_path = self.instance_path</span>
        <span class="s1">defaults = dict(self.default_config)</span>
        <span class="s1">defaults[</span><span class="s3">&quot;ENV&quot;</span><span class="s1">] = get_env()</span>
        <span class="s1">defaults[</span><span class="s3">&quot;DEBUG&quot;</span><span class="s1">] = get_debug_flag()</span>
        <span class="s2">return </span><span class="s1">self.config_class(root_path, defaults)</span>

    <span class="s2">def </span><span class="s1">auto_find_instance_path(self):</span>
        <span class="s0">&quot;&quot;&quot;Tries to locate the instance path if it was not provided to the 
        constructor of the application class.  It will basically calculate 
        the path to a folder named ``instance`` next to your main file or 
        the package. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s1">prefix, package_path = find_package(self.import_name)</span>
        <span class="s2">if </span><span class="s1">prefix </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">os.path.join(package_path, </span><span class="s3">&quot;instance&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">os.path.join(prefix, </span><span class="s3">&quot;var&quot;</span><span class="s1">, self.name + </span><span class="s3">&quot;-instance&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">open_instance_resource(self, resource, mode=</span><span class="s3">&quot;rb&quot;</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Opens a resource from the application's instance folder 
        (:attr:`instance_path`).  Otherwise works like 
        :meth:`open_resource`.  Instance resources can also be opened for 
        writing. 
 
        :param resource: the name of the resource.  To access resources within 
                         subfolders use forward slashes as separator. 
        :param mode: resource file opening mode, default is 'rb'. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">open(os.path.join(self.instance_path, resource), mode)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">templates_auto_reload(self):</span>
        <span class="s0">&quot;&quot;&quot;Reload templates when they are changed. Used by 
        :meth:`create_jinja_environment`. 
 
        This attribute can be configured with :data:`TEMPLATES_AUTO_RELOAD`. If 
        not set, it will be enabled in debug mode. 
 
        .. versionadded:: 1.0 
            This property was added but the underlying config and behavior 
            already existed. 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = self.config[</span><span class="s3">&quot;TEMPLATES_AUTO_RELOAD&quot;</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">rv </span><span class="s2">if </span><span class="s1">rv </span><span class="s2">is not None else </span><span class="s1">self.debug</span>

    <span class="s1">@templates_auto_reload.setter</span>
    <span class="s2">def </span><span class="s1">templates_auto_reload(self, value):</span>
        <span class="s1">self.config[</span><span class="s3">&quot;TEMPLATES_AUTO_RELOAD&quot;</span><span class="s1">] = value</span>

    <span class="s2">def </span><span class="s1">create_jinja_environment(self):</span>
        <span class="s0">&quot;&quot;&quot;Create the Jinja environment based on :attr:`jinja_options` 
        and the various Jinja-related methods of the app. Changing 
        :attr:`jinja_options` after this will have no effect. Also adds 
        Flask-related globals and filters to the environment. 
 
        .. versionchanged:: 0.11 
           ``Environment.auto_reload`` set in accordance with 
           ``TEMPLATES_AUTO_RELOAD`` configuration option. 
 
        .. versionadded:: 0.5 
        &quot;&quot;&quot;</span>
        <span class="s1">options = dict(self.jinja_options)</span>

        <span class="s2">if </span><span class="s3">&quot;autoescape&quot; </span><span class="s2">not in </span><span class="s1">options:</span>
            <span class="s1">options[</span><span class="s3">&quot;autoescape&quot;</span><span class="s1">] = self.select_jinja_autoescape</span>

        <span class="s2">if </span><span class="s3">&quot;auto_reload&quot; </span><span class="s2">not in </span><span class="s1">options:</span>
            <span class="s1">options[</span><span class="s3">&quot;auto_reload&quot;</span><span class="s1">] = self.templates_auto_reload</span>

        <span class="s1">rv = self.jinja_environment(self, **options)</span>
        <span class="s1">rv.globals.update(</span>
            <span class="s1">url_for=url_for,</span>
            <span class="s1">get_flashed_messages=get_flashed_messages,</span>
            <span class="s1">config=self.config,</span>
            <span class="s0"># request, session and g are normally added with the</span>
            <span class="s0"># context processor for efficiency reasons but for imported</span>
            <span class="s0"># templates we also want the proxies in there.</span>
            <span class="s1">request=request,</span>
            <span class="s1">session=session,</span>
            <span class="s1">g=g,</span>
        <span class="s1">)</span>
        <span class="s1">rv.filters[</span><span class="s3">&quot;tojson&quot;</span><span class="s1">] = json.tojson_filter</span>
        <span class="s2">return </span><span class="s1">rv</span>

    <span class="s2">def </span><span class="s1">create_global_jinja_loader(self):</span>
        <span class="s0">&quot;&quot;&quot;Creates the loader for the Jinja2 environment.  Can be used to 
        override just the loader and keeping the rest unchanged.  It's 
        discouraged to override this function.  Instead one should override 
        the :meth:`jinja_loader` function instead. 
 
        The global loader dispatches between the loaders of the application 
        and the individual blueprints. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">DispatchingJinjaLoader(self)</span>

    <span class="s2">def </span><span class="s1">select_jinja_autoescape(self, filename):</span>
        <span class="s0">&quot;&quot;&quot;Returns ``True`` if autoescaping should be active for the given 
        template name. If no template name is given, returns `True`. 
 
        .. versionadded:: 0.5 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">filename </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return True</span>
        <span class="s2">return </span><span class="s1">filename.endswith((</span><span class="s3">&quot;.html&quot;</span><span class="s1">, </span><span class="s3">&quot;.htm&quot;</span><span class="s1">, </span><span class="s3">&quot;.xml&quot;</span><span class="s1">, </span><span class="s3">&quot;.xhtml&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">update_template_context(self, context):</span>
        <span class="s0">&quot;&quot;&quot;Update the template context with some commonly used variables. 
        This injects request, session, config and g into the template 
        context as well as everything template context processors want 
        to inject.  Note that the as of Flask 0.6, the original values 
        in the context will not be overridden if a context processor 
        decides to return a value with the same key. 
 
        :param context: the context as a dictionary that is updated in place 
                        to add extra variables. 
        &quot;&quot;&quot;</span>
        <span class="s1">funcs = self.template_context_processors[</span><span class="s2">None</span><span class="s1">]</span>
        <span class="s1">reqctx = _request_ctx_stack.top</span>
        <span class="s2">if </span><span class="s1">reqctx </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">bp = reqctx.request.blueprint</span>
            <span class="s2">if </span><span class="s1">bp </span><span class="s2">is not None and </span><span class="s1">bp </span><span class="s2">in </span><span class="s1">self.template_context_processors:</span>
                <span class="s1">funcs = chain(funcs, self.template_context_processors[bp])</span>
        <span class="s1">orig_ctx = context.copy()</span>
        <span class="s2">for </span><span class="s1">func </span><span class="s2">in </span><span class="s1">funcs:</span>
            <span class="s1">context.update(func())</span>
        <span class="s0"># make sure the original values win.  This makes it possible to</span>
        <span class="s0"># easier add new variables in context processors without breaking</span>
        <span class="s0"># existing views.</span>
        <span class="s1">context.update(orig_ctx)</span>

    <span class="s2">def </span><span class="s1">make_shell_context(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns the shell context for an interactive shell for this 
        application.  This runs all the registered shell context 
        processors. 
 
        .. versionadded:: 0.11 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = {</span><span class="s3">&quot;app&quot;</span><span class="s1">: self, </span><span class="s3">&quot;g&quot;</span><span class="s1">: g}</span>
        <span class="s2">for </span><span class="s1">processor </span><span class="s2">in </span><span class="s1">self.shell_context_processors:</span>
            <span class="s1">rv.update(processor())</span>
        <span class="s2">return </span><span class="s1">rv</span>

    <span class="s0">#: What environment the app is running in. Flask and extensions may</span>
    <span class="s0">#: enable behaviors based on the environment, such as enabling debug</span>
    <span class="s0">#: mode. This maps to the :data:`ENV` config key. This is set by the</span>
    <span class="s0">#: :envvar:`FLASK_ENV` environment variable and may not behave as</span>
    <span class="s0">#: expected if set in code.</span>
    <span class="s0">#:</span>
    <span class="s0">#: **Do not enable development when deploying in production.**</span>
    <span class="s0">#:</span>
    <span class="s0">#: Default: ``'production'``</span>
    <span class="s1">env = ConfigAttribute(</span><span class="s3">&quot;ENV&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">debug(self):</span>
        <span class="s0">&quot;&quot;&quot;Whether debug mode is enabled. When using ``flask run`` to start 
        the development server, an interactive debugger will be shown for 
        unhandled exceptions, and the server will be reloaded when code 
        changes. This maps to the :data:`DEBUG` config key. This is 
        enabled when :attr:`env` is ``'development'`` and is overridden 
        by the ``FLASK_DEBUG`` environment variable. It may not behave as 
        expected if set in code. 
 
        **Do not enable debug mode when deploying in production.** 
 
        Default: ``True`` if :attr:`env` is ``'development'``, or 
        ``False`` otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.config[</span><span class="s3">&quot;DEBUG&quot;</span><span class="s1">]</span>

    <span class="s1">@debug.setter</span>
    <span class="s2">def </span><span class="s1">debug(self, value):</span>
        <span class="s1">self.config[</span><span class="s3">&quot;DEBUG&quot;</span><span class="s1">] = value</span>
        <span class="s1">self.jinja_env.auto_reload = self.templates_auto_reload</span>

    <span class="s2">def </span><span class="s1">run(self, host=</span><span class="s2">None</span><span class="s1">, port=</span><span class="s2">None</span><span class="s1">, debug=</span><span class="s2">None</span><span class="s1">, load_dotenv=</span><span class="s2">True</span><span class="s1">, **options):</span>
        <span class="s0">&quot;&quot;&quot;Runs the application on a local development server. 
 
        Do not use ``run()`` in a production setting. It is not intended to 
        meet security and performance requirements for a production server. 
        Instead, see :ref:`deployment` for WSGI server recommendations. 
 
        If the :attr:`debug` flag is set the server will automatically reload 
        for code changes and show a debugger in case an exception happened. 
 
        If you want to run the application in debug mode, but disable the 
        code execution on the interactive debugger, you can pass 
        ``use_evalex=False`` as parameter.  This will keep the debugger's 
        traceback screen active, but disable code execution. 
 
        It is not recommended to use this function for development with 
        automatic reloading as this is badly supported.  Instead you should 
        be using the :command:`flask` command line script's ``run`` support. 
 
        .. admonition:: Keep in Mind 
 
           Flask will suppress any server error with a generic error page 
           unless it is in debug mode.  As such to enable just the 
           interactive debugger without the code reloading, you have to 
           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``. 
           Setting ``use_debugger`` to ``True`` without being in debug mode 
           won't catch any exceptions because there won't be any to 
           catch. 
 
        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to 
            have the server available externally as well. Defaults to 
            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable 
            if present. 
        :param port: the port of the webserver. Defaults to ``5000`` or the 
            port defined in the ``SERVER_NAME`` config variable if present. 
        :param debug: if given, enable or disable debug mode. See 
            :attr:`debug`. 
        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv` 
            files to set environment variables. Will also change the working 
            directory to the directory containing the first file found. 
        :param options: the options to be forwarded to the underlying Werkzeug 
            server. See :func:`werkzeug.serving.run_simple` for more 
            information. 
 
        .. versionchanged:: 1.0 
            If installed, python-dotenv will be used to load environment 
            variables from :file:`.env` and :file:`.flaskenv` files. 
 
            If set, the :envvar:`FLASK_ENV` and :envvar:`FLASK_DEBUG` 
            environment variables will override :attr:`env` and 
            :attr:`debug`. 
 
            Threaded mode is enabled by default. 
 
        .. versionchanged:: 0.10 
            The default port is now picked from the ``SERVER_NAME`` 
            variable. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Change this into a no-op if the server is invoked from the</span>
        <span class="s0"># command line. Have a look at cli.py for more information.</span>
        <span class="s2">if </span><span class="s1">os.environ.get(</span><span class="s3">&quot;FLASK_RUN_FROM_CLI&quot;</span><span class="s1">) == </span><span class="s3">&quot;true&quot;</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">.debughelpers </span><span class="s2">import </span><span class="s1">explain_ignored_app_run</span>

            <span class="s1">explain_ignored_app_run()</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">get_load_dotenv(load_dotenv):</span>
            <span class="s1">cli.load_dotenv()</span>

            <span class="s0"># if set, let env vars override previous values</span>
            <span class="s2">if </span><span class="s3">&quot;FLASK_ENV&quot; </span><span class="s2">in </span><span class="s1">os.environ:</span>
                <span class="s1">self.env = get_env()</span>
                <span class="s1">self.debug = get_debug_flag()</span>
            <span class="s2">elif </span><span class="s3">&quot;FLASK_DEBUG&quot; </span><span class="s2">in </span><span class="s1">os.environ:</span>
                <span class="s1">self.debug = get_debug_flag()</span>

        <span class="s0"># debug passed to method overrides all other sources</span>
        <span class="s2">if </span><span class="s1">debug </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.debug = bool(debug)</span>

        <span class="s1">_host = </span><span class="s3">&quot;127.0.0.1&quot;</span>
        <span class="s1">_port = </span><span class="s5">5000</span>
        <span class="s1">server_name = self.config.get(</span><span class="s3">&quot;SERVER_NAME&quot;</span><span class="s1">)</span>
        <span class="s1">sn_host, sn_port = </span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">server_name:</span>
            <span class="s1">sn_host, _, sn_port = server_name.partition(</span><span class="s3">&quot;:&quot;</span><span class="s1">)</span>

        <span class="s1">host = host </span><span class="s2">or </span><span class="s1">sn_host </span><span class="s2">or </span><span class="s1">_host</span>
        <span class="s0"># pick the first value that's not None (0 is allowed)</span>
        <span class="s1">port = int(next((p </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">(port, sn_port) </span><span class="s2">if </span><span class="s1">p </span><span class="s2">is not None</span><span class="s1">), _port))</span>

        <span class="s1">options.setdefault(</span><span class="s3">&quot;use_reloader&quot;</span><span class="s1">, self.debug)</span>
        <span class="s1">options.setdefault(</span><span class="s3">&quot;use_debugger&quot;</span><span class="s1">, self.debug)</span>
        <span class="s1">options.setdefault(</span><span class="s3">&quot;threaded&quot;</span><span class="s1">, </span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">cli.show_server_banner(self.env, self.debug, self.name, </span><span class="s2">False</span><span class="s1">)</span>

        <span class="s2">from </span><span class="s1">werkzeug.serving </span><span class="s2">import </span><span class="s1">run_simple</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">run_simple(host, port, self, **options)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s0"># reset the first request information if the development server</span>
            <span class="s0"># reset normally.  This makes it possible to restart the server</span>
            <span class="s0"># without reloader and that stuff from an interactive shell.</span>
            <span class="s1">self._got_first_request = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">test_client(self, use_cookies=</span><span class="s2">True</span><span class="s1">, **kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Creates a test client for this application.  For information 
        about unit testing head over to :ref:`testing`. 
 
        Note that if you are testing for assertions or exceptions in your 
        application code, you must set ``app.testing = True`` in order for the 
        exceptions to propagate to the test client.  Otherwise, the exception 
        will be handled by the application (not visible to the test client) and 
        the only indication of an AssertionError or other exception will be a 
        500 status code response to the test client.  See the :attr:`testing` 
        attribute.  For example:: 
 
            app.testing = True 
            client = app.test_client() 
 
        The test client can be used in a ``with`` block to defer the closing down 
        of the context until the end of the ``with`` block.  This is useful if 
        you want to access the context locals for testing:: 
 
            with app.test_client() as c: 
                rv = c.get('/?vodka=42') 
                assert request.args['vodka'] == '42' 
 
        Additionally, you may pass optional keyword arguments that will then 
        be passed to the application's :attr:`test_client_class` constructor. 
        For example:: 
 
            from flask.testing import FlaskClient 
 
            class CustomClient(FlaskClient): 
                def __init__(self, *args, **kwargs): 
                    self._authentication = kwargs.pop(&quot;authentication&quot;) 
                    super(CustomClient,self).__init__( *args, **kwargs) 
 
            app.test_client_class = CustomClient 
            client = app.test_client(authentication='Basic ....') 
 
        See :class:`~flask.testing.FlaskClient` for more information. 
 
        .. versionchanged:: 0.4 
           added support for ``with`` block usage for the client. 
 
        .. versionadded:: 0.7 
           The `use_cookies` parameter was added as well as the ability 
           to override the client to be used by setting the 
           :attr:`test_client_class` attribute. 
 
        .. versionchanged:: 0.11 
           Added `**kwargs` to support passing additional keyword arguments to 
           the constructor of :attr:`test_client_class`. 
        &quot;&quot;&quot;</span>
        <span class="s1">cls = self.test_client_class</span>
        <span class="s2">if </span><span class="s1">cls </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">.testing </span><span class="s2">import </span><span class="s1">FlaskClient </span><span class="s2">as </span><span class="s1">cls</span>
        <span class="s2">return </span><span class="s1">cls(self, self.response_class, use_cookies=use_cookies, **kwargs)</span>

    <span class="s2">def </span><span class="s1">test_cli_runner(self, **kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Create a CLI runner for testing CLI commands. 
        See :ref:`testing-cli`. 
 
        Returns an instance of :attr:`test_cli_runner_class`, by default 
        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is 
        passed as the first argument. 
 
        .. versionadded:: 1.0 
        &quot;&quot;&quot;</span>
        <span class="s1">cls = self.test_cli_runner_class</span>

        <span class="s2">if </span><span class="s1">cls </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">.testing </span><span class="s2">import </span><span class="s1">FlaskCliRunner </span><span class="s2">as </span><span class="s1">cls</span>

        <span class="s2">return </span><span class="s1">cls(self, **kwargs)</span>

    <span class="s2">def </span><span class="s1">open_session(self, request):</span>
        <span class="s0">&quot;&quot;&quot;Creates or opens a new session.  Default implementation stores all 
        session data in a signed cookie.  This requires that the 
        :attr:`secret_key` is set.  Instead of overriding this method 
        we recommend replacing the :class:`session_interface`. 
 
        .. deprecated: 1.0 
            Will be removed in 2.0. Use 
            ``session_interface.open_session`` instead. 
 
        :param request: an instance of :attr:`request_class`. 
        &quot;&quot;&quot;</span>

        <span class="s1">warnings.warn(</span>
            <span class="s1">DeprecationWarning(</span>
                <span class="s3">'&quot;open_session&quot; is deprecated and will be removed in'</span>
                <span class="s3">' 2.0. Use &quot;session_interface.open_session&quot; instead.'</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.session_interface.open_session(self, request)</span>

    <span class="s2">def </span><span class="s1">save_session(self, session, response):</span>
        <span class="s0">&quot;&quot;&quot;Saves the session if it needs updates.  For the default 
        implementation, check :meth:`open_session`.  Instead of overriding this 
        method we recommend replacing the :class:`session_interface`. 
 
        .. deprecated: 1.0 
            Will be removed in 2.0. Use 
            ``session_interface.save_session`` instead. 
 
        :param session: the session to be saved (a 
                        :class:`~werkzeug.contrib.securecookie.SecureCookie` 
                        object) 
        :param response: an instance of :attr:`response_class` 
        &quot;&quot;&quot;</span>

        <span class="s1">warnings.warn(</span>
            <span class="s1">DeprecationWarning(</span>
                <span class="s3">'&quot;save_session&quot; is deprecated and will be removed in'</span>
                <span class="s3">' 2.0. Use &quot;session_interface.save_session&quot; instead.'</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.session_interface.save_session(self, session, response)</span>

    <span class="s2">def </span><span class="s1">make_null_session(self):</span>
        <span class="s0">&quot;&quot;&quot;Creates a new instance of a missing session.  Instead of overriding 
        this method we recommend replacing the :class:`session_interface`. 
 
        .. deprecated: 1.0 
            Will be removed in 2.0. Use 
            ``session_interface.make_null_session`` instead. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>

        <span class="s1">warnings.warn(</span>
            <span class="s1">DeprecationWarning(</span>
                <span class="s3">'&quot;make_null_session&quot; is deprecated and will be removed'</span>
                <span class="s3">' in 2.0. Use &quot;session_interface.make_null_session&quot;'</span>
                <span class="s3">&quot; instead.&quot;</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.session_interface.make_null_session(self)</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">register_blueprint(self, blueprint, **options):</span>
        <span class="s0">&quot;&quot;&quot;Register a :class:`~flask.Blueprint` on the application. Keyword 
        arguments passed to this method will override the defaults set on the 
        blueprint. 
 
        Calls the blueprint's :meth:`~flask.Blueprint.register` method after 
        recording the blueprint in the application's :attr:`blueprints`. 
 
        :param blueprint: The blueprint to register. 
        :param url_prefix: Blueprint routes will be prefixed with this. 
        :param subdomain: Blueprint routes will match on this subdomain. 
        :param url_defaults: Blueprint routes will use these default values for 
            view arguments. 
        :param options: Additional keyword arguments are passed to 
            :class:`~flask.blueprints.BlueprintSetupState`. They can be 
            accessed in :meth:`~flask.Blueprint.record` callbacks. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">first_registration = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">blueprint.name </span><span class="s2">in </span><span class="s1">self.blueprints:</span>
            <span class="s2">assert </span><span class="s1">self.blueprints[blueprint.name] </span><span class="s2">is </span><span class="s1">blueprint, (</span>
                <span class="s3">&quot;A name collision occurred between blueprints %r and %r. Both&quot;</span>
                <span class="s3">' share the same name &quot;%s&quot;. Blueprints that are created on the'</span>
                <span class="s3">&quot; fly need unique names.&quot;</span>
                <span class="s1">% (blueprint, self.blueprints[blueprint.name], blueprint.name)</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.blueprints[blueprint.name] = blueprint</span>
            <span class="s1">self._blueprint_order.append(blueprint)</span>
            <span class="s1">first_registration = </span><span class="s2">True</span>

        <span class="s1">blueprint.register(self, options, first_registration)</span>

    <span class="s2">def </span><span class="s1">iter_blueprints(self):</span>
        <span class="s0">&quot;&quot;&quot;Iterates over all blueprints by the order they were registered. 
 
        .. versionadded:: 0.11 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">iter(self._blueprint_order)</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">add_url_rule(</span>
        <span class="s1">self,</span>
        <span class="s1">rule,</span>
        <span class="s1">endpoint=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">view_func=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">provide_automatic_options=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">**options</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Connects a URL rule.  Works exactly like the :meth:`route` 
        decorator.  If a view_func is provided it will be registered with the 
        endpoint. 
 
        Basically this example:: 
 
            @app.route('/') 
            def index(): 
                pass 
 
        Is equivalent to the following:: 
 
            def index(): 
                pass 
            app.add_url_rule('/', 'index', index) 
 
        If the view_func is not provided you will need to connect the endpoint 
        to a view function like so:: 
 
            app.view_functions['index'] = index 
 
        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want 
        to customize the behavior via subclassing you only need to change 
        this method. 
 
        For more information refer to :ref:`url-route-registrations`. 
 
        .. versionchanged:: 0.2 
           `view_func` parameter added. 
 
        .. versionchanged:: 0.6 
           ``OPTIONS`` is added automatically as method. 
 
        :param rule: the URL rule as string 
        :param endpoint: the endpoint for the registered URL rule.  Flask 
                         itself assumes the name of the view function as 
                         endpoint 
        :param view_func: the function to call when serving a request to the 
                          provided endpoint 
        :param provide_automatic_options: controls whether the ``OPTIONS`` 
            method should be added automatically. This can also be controlled 
            by setting the ``view_func.provide_automatic_options = False`` 
            before adding the rule. 
        :param options: the options to be forwarded to the underlying 
                        :class:`~werkzeug.routing.Rule` object.  A change 
                        to Werkzeug is handling of method options.  methods 
                        is a list of methods this rule should be limited 
                        to (``GET``, ``POST`` etc.).  By default a rule 
                        just listens for ``GET`` (and implicitly ``HEAD``). 
                        Starting with Flask 0.6, ``OPTIONS`` is implicitly 
                        added and handled by the standard request handling. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">endpoint </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">endpoint = _endpoint_from_view_func(view_func)</span>
        <span class="s1">options[</span><span class="s3">&quot;endpoint&quot;</span><span class="s1">] = endpoint</span>
        <span class="s1">methods = options.pop(</span><span class="s3">&quot;methods&quot;</span><span class="s1">, </span><span class="s2">None</span><span class="s1">)</span>

        <span class="s0"># if the methods are not given and the view_func object knows its</span>
        <span class="s0"># methods we can use that instead.  If neither exists, we go with</span>
        <span class="s0"># a tuple of only ``GET`` as default.</span>
        <span class="s2">if </span><span class="s1">methods </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">methods = getattr(view_func, </span><span class="s3">&quot;methods&quot;</span><span class="s1">, </span><span class="s2">None</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(</span><span class="s3">&quot;GET&quot;</span><span class="s1">,)</span>
        <span class="s2">if </span><span class="s1">isinstance(methods, string_types):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s3">&quot;Allowed methods have to be iterables of strings, &quot;</span>
                <span class="s3">'for example: @app.route(..., methods=[&quot;POST&quot;])'</span>
            <span class="s1">)</span>
        <span class="s1">methods = set(item.upper() </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">methods)</span>

        <span class="s0"># Methods that should always be added</span>
        <span class="s1">required_methods = set(getattr(view_func, </span><span class="s3">&quot;required_methods&quot;</span><span class="s1">, ()))</span>

        <span class="s0"># starting with Flask 0.8 the view_func object can disable and</span>
        <span class="s0"># force-enable the automatic options handling.</span>
        <span class="s2">if </span><span class="s1">provide_automatic_options </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">provide_automatic_options = getattr(</span>
                <span class="s1">view_func, </span><span class="s3">&quot;provide_automatic_options&quot;</span><span class="s1">, </span><span class="s2">None</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">provide_automatic_options </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s3">&quot;OPTIONS&quot; </span><span class="s2">not in </span><span class="s1">methods:</span>
                <span class="s1">provide_automatic_options = </span><span class="s2">True</span>
                <span class="s1">required_methods.add(</span><span class="s3">&quot;OPTIONS&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">provide_automatic_options = </span><span class="s2">False</span>

        <span class="s0"># Add the required methods now.</span>
        <span class="s1">methods |= required_methods</span>

        <span class="s1">rule = self.url_rule_class(rule, methods=methods, **options)</span>
        <span class="s1">rule.provide_automatic_options = provide_automatic_options</span>

        <span class="s1">self.url_map.add(rule)</span>
        <span class="s2">if </span><span class="s1">view_func </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">old_func = self.view_functions.get(endpoint)</span>
            <span class="s2">if </span><span class="s1">old_func </span><span class="s2">is not None and </span><span class="s1">old_func != view_func:</span>
                <span class="s2">raise </span><span class="s1">AssertionError(</span>
                    <span class="s3">&quot;View function mapping is overwriting an &quot;</span>
                    <span class="s3">&quot;existing endpoint function: %s&quot; </span><span class="s1">% endpoint</span>
                <span class="s1">)</span>
            <span class="s1">self.view_functions[endpoint] = view_func</span>

    <span class="s2">def </span><span class="s1">route(self, rule, **options):</span>
        <span class="s0">&quot;&quot;&quot;A decorator that is used to register a view function for a 
        given URL rule.  This does the same thing as :meth:`add_url_rule` 
        but is intended for decorator usage:: 
 
            @app.route('/') 
            def index(): 
                return 'Hello World' 
 
        For more information refer to :ref:`url-route-registrations`. 
 
        :param rule: the URL rule as string 
        :param endpoint: the endpoint for the registered URL rule.  Flask 
                         itself assumes the name of the view function as 
                         endpoint 
        :param options: the options to be forwarded to the underlying 
                        :class:`~werkzeug.routing.Rule` object.  A change 
                        to Werkzeug is handling of method options.  methods 
                        is a list of methods this rule should be limited 
                        to (``GET``, ``POST`` etc.).  By default a rule 
                        just listens for ``GET`` (and implicitly ``HEAD``). 
                        Starting with Flask 0.6, ``OPTIONS`` is implicitly 
                        added and handled by the standard request handling. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">decorator(f):</span>
            <span class="s1">endpoint = options.pop(</span><span class="s3">&quot;endpoint&quot;</span><span class="s1">, </span><span class="s2">None</span><span class="s1">)</span>
            <span class="s1">self.add_url_rule(rule, endpoint, f, **options)</span>
            <span class="s2">return </span><span class="s1">f</span>

        <span class="s2">return </span><span class="s1">decorator</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">endpoint(self, endpoint):</span>
        <span class="s0">&quot;&quot;&quot;A decorator to register a function as an endpoint. 
        Example:: 
 
            @app.endpoint('example.endpoint') 
            def example(): 
                return &quot;example&quot; 
 
        :param endpoint: the name of the endpoint 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">decorator(f):</span>
            <span class="s1">self.view_functions[endpoint] = f</span>
            <span class="s2">return </span><span class="s1">f</span>

        <span class="s2">return </span><span class="s1">decorator</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_get_exc_class_and_code(exc_class_or_code):</span>
        <span class="s0">&quot;&quot;&quot;Get the exception class being handled. For HTTP status codes 
        or ``HTTPException`` subclasses, return both the exception and 
        status code. 
 
        :param exc_class_or_code: Any exception class, or an HTTP status 
            code as an integer. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(exc_class_or_code, integer_types):</span>
            <span class="s1">exc_class = default_exceptions[exc_class_or_code]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">exc_class = exc_class_or_code</span>

        <span class="s2">assert </span><span class="s1">issubclass(exc_class, Exception)</span>

        <span class="s2">if </span><span class="s1">issubclass(exc_class, HTTPException):</span>
            <span class="s2">return </span><span class="s1">exc_class, exc_class.code</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">exc_class, </span><span class="s2">None</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">errorhandler(self, code_or_exception):</span>
        <span class="s0">&quot;&quot;&quot;Register a function to handle errors by code or exception class. 
 
        A decorator that is used to register a function given an 
        error code.  Example:: 
 
            @app.errorhandler(404) 
            def page_not_found(error): 
                return 'This page does not exist', 404 
 
        You can also register handlers for arbitrary exceptions:: 
 
            @app.errorhandler(DatabaseError) 
            def special_exception_handler(error): 
                return 'Database connection failed', 500 
 
        .. versionadded:: 0.7 
            Use :meth:`register_error_handler` instead of modifying 
            :attr:`error_handler_spec` directly, for application wide error 
            handlers. 
 
        .. versionadded:: 0.7 
           One can now additionally also register custom exception types 
           that do not necessarily have to be a subclass of the 
           :class:`~werkzeug.exceptions.HTTPException` class. 
 
        :param code_or_exception: the code as integer for the handler, or 
                                  an arbitrary exception 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">decorator(f):</span>
            <span class="s1">self._register_error_handler(</span><span class="s2">None</span><span class="s1">, code_or_exception, f)</span>
            <span class="s2">return </span><span class="s1">f</span>

        <span class="s2">return </span><span class="s1">decorator</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">register_error_handler(self, code_or_exception, f):</span>
        <span class="s0">&quot;&quot;&quot;Alternative error attach function to the :meth:`errorhandler` 
        decorator that is more straightforward to use for non decorator 
        usage. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">self._register_error_handler(</span><span class="s2">None</span><span class="s1">, code_or_exception, f)</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">_register_error_handler(self, key, code_or_exception, f):</span>
        <span class="s0">&quot;&quot;&quot; 
        :type key: None|str 
        :type code_or_exception: int|T&lt;=Exception 
        :type f: callable 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(code_or_exception, HTTPException):  </span><span class="s0"># old broken behavior</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Tried to register a handler for an exception instance {0!r}.&quot;</span>
                <span class="s3">&quot; Handlers can only be registered for exception classes or&quot;</span>
                <span class="s3">&quot; HTTP error codes.&quot;</span><span class="s1">.format(code_or_exception)</span>
            <span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">exc_class, code = self._get_exc_class_and_code(code_or_exception)</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">raise </span><span class="s1">KeyError(</span>
                <span class="s3">&quot;'{0}' is not a recognized HTTP error code. Use a subclass of&quot;</span>
                <span class="s3">&quot; HTTPException with that code instead.&quot;</span><span class="s1">.format(code_or_exception)</span>
            <span class="s1">)</span>

        <span class="s1">handlers = self.error_handler_spec.setdefault(key, {}).setdefault(code, {})</span>
        <span class="s1">handlers[exc_class] = f</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">template_filter(self, name=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;A decorator that is used to register custom template filter. 
        You can specify a name for the filter, otherwise the function 
        name will be used. Example:: 
 
          @app.template_filter() 
          def reverse(s): 
              return s[::-1] 
 
        :param name: the optional name of the filter, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">decorator(f):</span>
            <span class="s1">self.add_template_filter(f, name=name)</span>
            <span class="s2">return </span><span class="s1">f</span>

        <span class="s2">return </span><span class="s1">decorator</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">add_template_filter(self, f, name=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Register a custom template filter.  Works exactly like the 
        :meth:`template_filter` decorator. 
 
        :param name: the optional name of the filter, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.jinja_env.filters[name </span><span class="s2">or </span><span class="s1">f.__name__] = f</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">template_test(self, name=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;A decorator that is used to register custom template test. 
        You can specify a name for the test, otherwise the function 
        name will be used. Example:: 
 
          @app.template_test() 
          def is_prime(n): 
              if n == 2: 
                  return True 
              for i in range(2, int(math.ceil(math.sqrt(n))) + 1): 
                  if n % i == 0: 
                      return False 
              return True 
 
        .. versionadded:: 0.10 
 
        :param name: the optional name of the test, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">decorator(f):</span>
            <span class="s1">self.add_template_test(f, name=name)</span>
            <span class="s2">return </span><span class="s1">f</span>

        <span class="s2">return </span><span class="s1">decorator</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">add_template_test(self, f, name=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Register a custom template test.  Works exactly like the 
        :meth:`template_test` decorator. 
 
        .. versionadded:: 0.10 
 
        :param name: the optional name of the test, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.jinja_env.tests[name </span><span class="s2">or </span><span class="s1">f.__name__] = f</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">template_global(self, name=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;A decorator that is used to register a custom template global function. 
        You can specify a name for the global function, otherwise the function 
        name will be used. Example:: 
 
            @app.template_global() 
            def double(n): 
                return 2 * n 
 
        .. versionadded:: 0.10 
 
        :param name: the optional name of the global function, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">decorator(f):</span>
            <span class="s1">self.add_template_global(f, name=name)</span>
            <span class="s2">return </span><span class="s1">f</span>

        <span class="s2">return </span><span class="s1">decorator</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">add_template_global(self, f, name=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Register a custom template global function. Works exactly like the 
        :meth:`template_global` decorator. 
 
        .. versionadded:: 0.10 
 
        :param name: the optional name of the global function, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.jinja_env.globals[name </span><span class="s2">or </span><span class="s1">f.__name__] = f</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">before_request(self, f):</span>
        <span class="s0">&quot;&quot;&quot;Registers a function to run before each request. 
 
        For example, this can be used to open a database connection, or to load 
        the logged in user from the session. 
 
        The function will be called without any arguments. If it returns a 
        non-None value, the value is handled as if it was the return value from 
        the view, and further request handling is stopped. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.before_request_funcs.setdefault(</span><span class="s2">None</span><span class="s1">, []).append(f)</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">before_first_request(self, f):</span>
        <span class="s0">&quot;&quot;&quot;Registers a function to be run before the first request to this 
        instance of the application. 
 
        The function will be called without any arguments and its return 
        value is ignored. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s1">self.before_first_request_funcs.append(f)</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">after_request(self, f):</span>
        <span class="s0">&quot;&quot;&quot;Register a function to be run after each request. 
 
        Your function must take one parameter, an instance of 
        :attr:`response_class` and return a new response object or the 
        same (see :meth:`process_response`). 
 
        As of Flask 0.7 this function might not be executed at the end of the 
        request in case an unhandled exception occurred. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.after_request_funcs.setdefault(</span><span class="s2">None</span><span class="s1">, []).append(f)</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">teardown_request(self, f):</span>
        <span class="s0">&quot;&quot;&quot;Register a function to be run at the end of each request, 
        regardless of whether there was an exception or not.  These functions 
        are executed when the request context is popped, even if not an 
        actual request was performed. 
 
        Example:: 
 
            ctx = app.test_request_context() 
            ctx.push() 
            ... 
            ctx.pop() 
 
        When ``ctx.pop()`` is executed in the above example, the teardown 
        functions are called just before the request context moves from the 
        stack of active contexts.  This becomes relevant if you are using 
        such constructs in tests. 
 
        Generally teardown functions must take every necessary step to avoid 
        that they will fail.  If they do execute code that might fail they 
        will have to surround the execution of these code by try/except 
        statements and log occurring errors. 
 
        When a teardown function was called because of an exception it will 
        be passed an error object. 
 
        The return values of teardown functions are ignored. 
 
        .. admonition:: Debug Note 
 
           In debug mode Flask will not tear down a request on an exception 
           immediately.  Instead it will keep it alive so that the interactive 
           debugger can still access it.  This behavior can be controlled 
           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.teardown_request_funcs.setdefault(</span><span class="s2">None</span><span class="s1">, []).append(f)</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">teardown_appcontext(self, f):</span>
        <span class="s0">&quot;&quot;&quot;Registers a function to be called when the application context 
        ends.  These functions are typically also called when the request 
        context is popped. 
 
        Example:: 
 
            ctx = app.app_context() 
            ctx.push() 
            ... 
            ctx.pop() 
 
        When ``ctx.pop()`` is executed in the above example, the teardown 
        functions are called just before the app context moves from the 
        stack of active contexts.  This becomes relevant if you are using 
        such constructs in tests. 
 
        Since a request context typically also manages an application 
        context it would also be called when you pop a request context. 
 
        When a teardown function was called because of an unhandled exception 
        it will be passed an error object. If an :meth:`errorhandler` is 
        registered, it will handle the exception and the teardown will not 
        receive it. 
 
        The return values of teardown functions are ignored. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s1">self.teardown_appcontext_funcs.append(f)</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">context_processor(self, f):</span>
        <span class="s0">&quot;&quot;&quot;Registers a template context processor function.&quot;&quot;&quot;</span>
        <span class="s1">self.template_context_processors[</span><span class="s2">None</span><span class="s1">].append(f)</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">shell_context_processor(self, f):</span>
        <span class="s0">&quot;&quot;&quot;Registers a shell context processor function. 
 
        .. versionadded:: 0.11 
        &quot;&quot;&quot;</span>
        <span class="s1">self.shell_context_processors.append(f)</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">url_value_preprocessor(self, f):</span>
        <span class="s0">&quot;&quot;&quot;Register a URL value preprocessor function for all view 
        functions in the application. These functions will be called before the 
        :meth:`before_request` functions. 
 
        The function can modify the values captured from the matched url before 
        they are passed to the view. For example, this can be used to pop a 
        common language code value and place it in ``g`` rather than pass it to 
        every view. 
 
        The function is passed the endpoint name and values dict. The return 
        value is ignored. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.url_value_preprocessors.setdefault(</span><span class="s2">None</span><span class="s1">, []).append(f)</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s1">@setupmethod</span>
    <span class="s2">def </span><span class="s1">url_defaults(self, f):</span>
        <span class="s0">&quot;&quot;&quot;Callback function for URL defaults for all view functions of the 
        application.  It's called with the endpoint and values and should 
        update the values passed in place. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.url_default_functions.setdefault(</span><span class="s2">None</span><span class="s1">, []).append(f)</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s2">def </span><span class="s1">_find_error_handler(self, e):</span>
        <span class="s0">&quot;&quot;&quot;Return a registered error handler for an exception in this order: 
        blueprint handler for a specific code, app handler for a specific code, 
        blueprint handler for an exception class, app handler for an exception 
        class, or ``None`` if a suitable handler is not found. 
        &quot;&quot;&quot;</span>
        <span class="s1">exc_class, code = self._get_exc_class_and_code(type(e))</span>

        <span class="s2">for </span><span class="s1">name, c </span><span class="s2">in </span><span class="s1">(</span>
            <span class="s1">(request.blueprint, code),</span>
            <span class="s1">(</span><span class="s2">None</span><span class="s1">, code),</span>
            <span class="s1">(request.blueprint, </span><span class="s2">None</span><span class="s1">),</span>
            <span class="s1">(</span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">),</span>
        <span class="s1">):</span>
            <span class="s1">handler_map = self.error_handler_spec.setdefault(name, {}).get(c)</span>

            <span class="s2">if not </span><span class="s1">handler_map:</span>
                <span class="s2">continue</span>

            <span class="s2">for </span><span class="s1">cls </span><span class="s2">in </span><span class="s1">exc_class.__mro__:</span>
                <span class="s1">handler = handler_map.get(cls)</span>

                <span class="s2">if </span><span class="s1">handler </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">handler</span>

    <span class="s2">def </span><span class="s1">handle_http_exception(self, e):</span>
        <span class="s0">&quot;&quot;&quot;Handles an HTTP exception.  By default this will invoke the 
        registered error handlers and fall back to returning the 
        exception as response. 
 
        .. versionchanged:: 1.0.3 
            ``RoutingException``, used internally for actions such as 
             slash redirects during routing, is not passed to error 
             handlers. 
 
        .. versionchanged:: 1.0 
            Exceptions are looked up by code *and* by MRO, so 
            ``HTTPExcpetion`` subclasses can be handled with a catch-all 
            handler for the base ``HTTPException``. 
 
        .. versionadded:: 0.3 
        &quot;&quot;&quot;</span>
        <span class="s0"># Proxy exceptions don't have error codes.  We want to always return</span>
        <span class="s0"># those unchanged as errors</span>
        <span class="s2">if </span><span class="s1">e.code </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">e</span>

        <span class="s0"># RoutingExceptions are used internally to trigger routing</span>
        <span class="s0"># actions, such as slash redirects raising RequestRedirect. They</span>
        <span class="s0"># are not raised or handled in user code.</span>
        <span class="s2">if </span><span class="s1">isinstance(e, RoutingException):</span>
            <span class="s2">return </span><span class="s1">e</span>

        <span class="s1">handler = self._find_error_handler(e)</span>
        <span class="s2">if </span><span class="s1">handler </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">e</span>
        <span class="s2">return </span><span class="s1">handler(e)</span>

    <span class="s2">def </span><span class="s1">trap_http_exception(self, e):</span>
        <span class="s0">&quot;&quot;&quot;Checks if an HTTP exception should be trapped or not.  By default 
        this will return ``False`` for all exceptions except for a bad request 
        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It 
        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``. 
 
        This is called for all HTTP exceptions raised by a view function. 
        If it returns ``True`` for any exception the error handler for this 
        exception is not called and it shows up as regular exception in the 
        traceback.  This is helpful for debugging implicitly raised HTTP 
        exceptions. 
 
        .. versionchanged:: 1.0 
            Bad request errors are not trapped by default in debug mode. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.config[</span><span class="s3">&quot;TRAP_HTTP_EXCEPTIONS&quot;</span><span class="s1">]:</span>
            <span class="s2">return True</span>

        <span class="s1">trap_bad_request = self.config[</span><span class="s3">&quot;TRAP_BAD_REQUEST_ERRORS&quot;</span><span class="s1">]</span>

        <span class="s0"># if unset, trap key errors in debug mode</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">trap_bad_request </span><span class="s2">is None</span>
            <span class="s2">and </span><span class="s1">self.debug</span>
            <span class="s2">and </span><span class="s1">isinstance(e, BadRequestKeyError)</span>
        <span class="s1">):</span>
            <span class="s2">return True</span>

        <span class="s2">if </span><span class="s1">trap_bad_request:</span>
            <span class="s2">return </span><span class="s1">isinstance(e, BadRequest)</span>

        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">handle_user_exception(self, e):</span>
        <span class="s0">&quot;&quot;&quot;This method is called whenever an exception occurs that 
        should be handled. A special case is :class:`~werkzeug 
        .exceptions.HTTPException` which is forwarded to the 
        :meth:`handle_http_exception` method. This function will either 
        return a response value or reraise the exception with the same 
        traceback. 
 
        .. versionchanged:: 1.0 
            Key errors raised from request data like ``form`` show the 
            bad key in debug mode rather than a generic bad request 
            message. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">exc_type, exc_value, tb = sys.exc_info()</span>
        <span class="s2">assert </span><span class="s1">exc_value </span><span class="s2">is </span><span class="s1">e</span>
        <span class="s0"># ensure not to trash sys.exc_info() at that point in case someone</span>
        <span class="s0"># wants the traceback preserved in handle_http_exception.  Of course</span>
        <span class="s0"># we cannot prevent users from trashing it themselves in a custom</span>
        <span class="s0"># trap_http_exception method so that's their fault then.</span>

        <span class="s2">if </span><span class="s1">isinstance(e, BadRequestKeyError):</span>
            <span class="s2">if </span><span class="s1">self.debug </span><span class="s2">or </span><span class="s1">self.config[</span><span class="s3">&quot;TRAP_BAD_REQUEST_ERRORS&quot;</span><span class="s1">]:</span>
                <span class="s1">e.show_exception = </span><span class="s2">True</span>

                <span class="s0"># Werkzeug &lt; 0.15 doesn't add the KeyError to the 400</span>
                <span class="s0"># message, add it in manually.</span>
                <span class="s0"># TODO: clean up once Werkzeug &gt;= 0.15.5 is required</span>
                <span class="s2">if </span><span class="s1">e.args[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">e.get_description():</span>
                    <span class="s1">e.description = </span><span class="s3">&quot;KeyError: '{}'&quot;</span><span class="s1">.format(*e.args)</span>
            <span class="s2">elif not </span><span class="s1">hasattr(BadRequestKeyError, </span><span class="s3">&quot;show_exception&quot;</span><span class="s1">):</span>
                <span class="s1">e.args = ()</span>

        <span class="s2">if </span><span class="s1">isinstance(e, HTTPException) </span><span class="s2">and not </span><span class="s1">self.trap_http_exception(e):</span>
            <span class="s2">return </span><span class="s1">self.handle_http_exception(e)</span>

        <span class="s1">handler = self._find_error_handler(e)</span>

        <span class="s2">if </span><span class="s1">handler </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">reraise(exc_type, exc_value, tb)</span>
        <span class="s2">return </span><span class="s1">handler(e)</span>

    <span class="s2">def </span><span class="s1">handle_exception(self, e):</span>
        <span class="s0">&quot;&quot;&quot;Handle an exception that did not have an error handler 
        associated with it, or that was raised from an error handler. 
        This always causes a 500 ``InternalServerError``. 
 
        Always sends the :data:`got_request_exception` signal. 
 
        If :attr:`propagate_exceptions` is ``True``, such as in debug 
        mode, the error will be re-raised so that the debugger can 
        display it. Otherwise, the original exception is logged, and 
        an :exc:`~werkzeug.exceptions.InternalServerError` is returned. 
 
        If an error handler is registered for ``InternalServerError`` or 
        ``500``, it will be used. For consistency, the handler will 
        always receive the ``InternalServerError``. The original 
        unhandled exception is available as ``e.original_exception``. 
 
        .. note:: 
            Prior to Werkzeug 1.0.0, ``InternalServerError`` will not 
            always have an ``original_exception`` attribute. Use 
            ``getattr(e, &quot;original_exception&quot;, None)`` to simulate the 
            behavior for compatibility. 
 
        .. versionchanged:: 1.1.0 
            Always passes the ``InternalServerError`` instance to the 
            handler, setting ``original_exception`` to the unhandled 
            error. 
 
        .. versionchanged:: 1.1.0 
            ``after_request`` functions and other finalization is done 
            even for the default 500 response when there is no handler. 
 
        .. versionadded:: 0.3 
        &quot;&quot;&quot;</span>
        <span class="s1">exc_type, exc_value, tb = sys.exc_info()</span>
        <span class="s1">got_request_exception.send(self, exception=e)</span>

        <span class="s2">if </span><span class="s1">self.propagate_exceptions:</span>
            <span class="s0"># if we want to repropagate the exception, we can attempt to</span>
            <span class="s0"># raise it with the whole traceback in case we can do that</span>
            <span class="s0"># (the function was actually called from the except part)</span>
            <span class="s0"># otherwise, we just raise the error again</span>
            <span class="s2">if </span><span class="s1">exc_value </span><span class="s2">is </span><span class="s1">e:</span>
                <span class="s1">reraise(exc_type, exc_value, tb)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">e</span>

        <span class="s1">self.log_exception((exc_type, exc_value, tb))</span>
        <span class="s1">server_error = InternalServerError()</span>
        <span class="s0"># TODO: pass as param when Werkzeug&gt;=1.0.0 is required</span>
        <span class="s0"># TODO: also remove note about this from docstring and docs</span>
        <span class="s1">server_error.original_exception = e</span>
        <span class="s1">handler = self._find_error_handler(server_error)</span>

        <span class="s2">if </span><span class="s1">handler </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">server_error = handler(server_error)</span>

        <span class="s2">return </span><span class="s1">self.finalize_request(server_error, from_error_handler=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">log_exception(self, exc_info):</span>
        <span class="s0">&quot;&quot;&quot;Logs an exception.  This is called by :meth:`handle_exception` 
        if debugging is disabled and right before the handler is called. 
        The default implementation logs the exception as error on the 
        :attr:`logger`. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s1">self.logger.error(</span>
            <span class="s3">&quot;Exception on %s [%s]&quot; </span><span class="s1">% (request.path, request.method), exc_info=exc_info</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">raise_routing_exception(self, request):</span>
        <span class="s0">&quot;&quot;&quot;Exceptions that are recording during routing are reraised with 
        this method.  During debug we are not reraising redirect requests 
        for non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising 
        a different error instead to help debug situations. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">self.debug</span>
            <span class="s2">or not </span><span class="s1">isinstance(request.routing_exception, RequestRedirect)</span>
            <span class="s2">or </span><span class="s1">request.method </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;GET&quot;</span><span class="s1">, </span><span class="s3">&quot;HEAD&quot;</span><span class="s1">, </span><span class="s3">&quot;OPTIONS&quot;</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">request.routing_exception</span>

        <span class="s2">from </span><span class="s1">.debughelpers </span><span class="s2">import </span><span class="s1">FormDataRoutingRedirect</span>

        <span class="s2">raise </span><span class="s1">FormDataRoutingRedirect(request)</span>

    <span class="s2">def </span><span class="s1">dispatch_request(self):</span>
        <span class="s0">&quot;&quot;&quot;Does the request dispatching.  Matches the URL and returns the 
        return value of the view or error handler.  This does not have to 
        be a response object.  In order to convert the return value to a 
        proper response object, call :func:`make_response`. 
 
        .. versionchanged:: 0.7 
           This no longer does the exception handling, this code was 
           moved to the new :meth:`full_dispatch_request`. 
        &quot;&quot;&quot;</span>
        <span class="s1">req = _request_ctx_stack.top.request</span>
        <span class="s2">if </span><span class="s1">req.routing_exception </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.raise_routing_exception(req)</span>
        <span class="s1">rule = req.url_rule</span>
        <span class="s0"># if we provide automatic options for this URL and the</span>
        <span class="s0"># request came with the OPTIONS method, reply automatically</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">getattr(rule, </span><span class="s3">&quot;provide_automatic_options&quot;</span><span class="s1">, </span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">and </span><span class="s1">req.method == </span><span class="s3">&quot;OPTIONS&quot;</span>
        <span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self.make_default_options_response()</span>
        <span class="s0"># otherwise dispatch to the handler for that endpoint</span>
        <span class="s2">return </span><span class="s1">self.view_functions[rule.endpoint](**req.view_args)</span>

    <span class="s2">def </span><span class="s1">full_dispatch_request(self):</span>
        <span class="s0">&quot;&quot;&quot;Dispatches the request and on top of that performs request 
        pre and postprocessing as well as HTTP exception catching and 
        error handling. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">self.try_trigger_before_first_request_functions()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">request_started.send(self)</span>
            <span class="s1">rv = self.preprocess_request()</span>
            <span class="s2">if </span><span class="s1">rv </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">rv = self.dispatch_request()</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">rv = self.handle_user_exception(e)</span>
        <span class="s2">return </span><span class="s1">self.finalize_request(rv)</span>

    <span class="s2">def </span><span class="s1">finalize_request(self, rv, from_error_handler=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Given the return value from a view function this finalizes 
        the request by converting it into a response and invoking the 
        postprocessing functions.  This is invoked for both normal 
        request dispatching as well as error handlers. 
 
        Because this means that it might be called as a result of a 
        failure a special safe mode is available which can be enabled 
        with the `from_error_handler` flag.  If enabled, failures in 
        response processing will be logged and otherwise ignored. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s1">response = self.make_response(rv)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">response = self.process_response(response)</span>
            <span class="s1">request_finished.send(self, response=response)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">if not </span><span class="s1">from_error_handler:</span>
                <span class="s2">raise</span>
            <span class="s1">self.logger.exception(</span>
                <span class="s3">&quot;Request finalizing failed with an error while handling an error&quot;</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">response</span>

    <span class="s2">def </span><span class="s1">try_trigger_before_first_request_functions(self):</span>
        <span class="s0">&quot;&quot;&quot;Called before each request and will ensure that it triggers 
        the :attr:`before_first_request_funcs` and only exactly once per 
        application instance (which means process usually). 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._got_first_request:</span>
            <span class="s2">return</span>
        <span class="s2">with </span><span class="s1">self._before_request_lock:</span>
            <span class="s2">if </span><span class="s1">self._got_first_request:</span>
                <span class="s2">return</span>
            <span class="s2">for </span><span class="s1">func </span><span class="s2">in </span><span class="s1">self.before_first_request_funcs:</span>
                <span class="s1">func()</span>
            <span class="s1">self._got_first_request = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">make_default_options_response(self):</span>
        <span class="s0">&quot;&quot;&quot;This method is called to create the default ``OPTIONS`` response. 
        This can be changed through subclassing to change the default 
        behavior of ``OPTIONS`` responses. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">adapter = _request_ctx_stack.top.url_adapter</span>
        <span class="s2">if </span><span class="s1">hasattr(adapter, </span><span class="s3">&quot;allowed_methods&quot;</span><span class="s1">):</span>
            <span class="s1">methods = adapter.allowed_methods()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># fallback for Werkzeug &lt; 0.7</span>
            <span class="s1">methods = []</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">adapter.match(method=</span><span class="s3">&quot;--&quot;</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">MethodNotAllowed </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">methods = e.valid_methods</span>
            <span class="s2">except </span><span class="s1">HTTPException:</span>
                <span class="s2">pass</span>
        <span class="s1">rv = self.response_class()</span>
        <span class="s1">rv.allow.update(methods)</span>
        <span class="s2">return </span><span class="s1">rv</span>

    <span class="s2">def </span><span class="s1">should_ignore_error(self, error):</span>
        <span class="s0">&quot;&quot;&quot;This is called to figure out if an error should be ignored 
        or not as far as the teardown system is concerned.  If this 
        function returns ``True`` then the teardown handlers will not be 
        passed the error. 
 
        .. versionadded:: 0.10 
        &quot;&quot;&quot;</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">make_response(self, rv):</span>
        <span class="s0">&quot;&quot;&quot;Convert the return value from a view function to an instance of 
        :attr:`response_class`. 
 
        :param rv: the return value from the view function. The view function 
            must return a response. Returning ``None``, or the view ending 
            without returning, is not allowed. The following types are allowed 
            for ``view_rv``: 
 
            ``str`` (``unicode`` in Python 2) 
                A response object is created with the string encoded to UTF-8 
                as the body. 
 
            ``bytes`` (``str`` in Python 2) 
                A response object is created with the bytes as the body. 
 
            ``dict`` 
                A dictionary that will be jsonify'd before being returned. 
 
            ``tuple`` 
                Either ``(body, status, headers)``, ``(body, status)``, or 
                ``(body, headers)``, where ``body`` is any of the other types 
                allowed here, ``status`` is a string or an integer, and 
                ``headers`` is a dictionary or a list of ``(key, value)`` 
                tuples. If ``body`` is a :attr:`response_class` instance, 
                ``status`` overwrites the exiting value and ``headers`` are 
                extended. 
 
            :attr:`response_class` 
                The object is returned unchanged. 
 
            other :class:`~werkzeug.wrappers.Response` class 
                The object is coerced to :attr:`response_class`. 
 
            :func:`callable` 
                The function is called as a WSGI application. The result is 
                used to create a response object. 
 
        .. versionchanged:: 0.9 
           Previously a tuple was interpreted as the arguments for the 
           response object. 
        &quot;&quot;&quot;</span>

        <span class="s1">status = headers = </span><span class="s2">None</span>

        <span class="s0"># unpack tuple returns</span>
        <span class="s2">if </span><span class="s1">isinstance(rv, tuple):</span>
            <span class="s1">len_rv = len(rv)</span>

            <span class="s0"># a 3-tuple is unpacked directly</span>
            <span class="s2">if </span><span class="s1">len_rv == </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s1">rv, status, headers = rv</span>
            <span class="s0"># decide if a 2-tuple has status or headers</span>
            <span class="s2">elif </span><span class="s1">len_rv == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">isinstance(rv[</span><span class="s5">1</span><span class="s1">], (Headers, dict, tuple, list)):</span>
                    <span class="s1">rv, headers = rv</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">rv, status = rv</span>
            <span class="s0"># other sized tuples are not allowed</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;The view function did not return a valid response tuple.&quot;</span>
                    <span class="s3">&quot; The tuple must have the form (body, status, headers),&quot;</span>
                    <span class="s3">&quot; (body, status), or (body, headers).&quot;</span>
                <span class="s1">)</span>

        <span class="s0"># the body must not be None</span>
        <span class="s2">if </span><span class="s1">rv </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s3">&quot;The view function did not return a valid response. The&quot;</span>
                <span class="s3">&quot; function either returned None or ended without a return&quot;</span>
                <span class="s3">&quot; statement.&quot;</span>
            <span class="s1">)</span>

        <span class="s0"># make sure the body is an instance of the response class</span>
        <span class="s2">if not </span><span class="s1">isinstance(rv, self.response_class):</span>
            <span class="s2">if </span><span class="s1">isinstance(rv, (text_type, bytes, bytearray)):</span>
                <span class="s0"># let the response class set the status and headers instead of</span>
                <span class="s0"># waiting to do it manually, so that the class can handle any</span>
                <span class="s0"># special logic</span>
                <span class="s1">rv = self.response_class(rv, status=status, headers=headers)</span>
                <span class="s1">status = headers = </span><span class="s2">None</span>
            <span class="s2">elif </span><span class="s1">isinstance(rv, dict):</span>
                <span class="s1">rv = jsonify(rv)</span>
            <span class="s2">elif </span><span class="s1">isinstance(rv, BaseResponse) </span><span class="s2">or </span><span class="s1">callable(rv):</span>
                <span class="s0"># evaluate a WSGI callable, or coerce a different response</span>
                <span class="s0"># class to the correct type</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">rv = self.response_class.force_type(rv, request.environ)</span>
                <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e:</span>
                    <span class="s1">new_error = TypeError(</span>
                        <span class="s3">&quot;{e}</span><span class="s4">\n</span><span class="s3">The view function did not return a valid&quot;</span>
                        <span class="s3">&quot; response. The return type must be a string, dict, tuple,&quot;</span>
                        <span class="s3">&quot; Response instance, or WSGI callable, but it was a&quot;</span>
                        <span class="s3">&quot; {rv.__class__.__name__}.&quot;</span><span class="s1">.format(e=e, rv=rv)</span>
                    <span class="s1">)</span>
                    <span class="s1">reraise(TypeError, new_error, sys.exc_info()[</span><span class="s5">2</span><span class="s1">])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;The view function did not return a valid&quot;</span>
                    <span class="s3">&quot; response. The return type must be a string, dict, tuple,&quot;</span>
                    <span class="s3">&quot; Response instance, or WSGI callable, but it was a&quot;</span>
                    <span class="s3">&quot; {rv.__class__.__name__}.&quot;</span><span class="s1">.format(rv=rv)</span>
                <span class="s1">)</span>

        <span class="s0"># prefer the status if it was provided</span>
        <span class="s2">if </span><span class="s1">status </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(status, (text_type, bytes, bytearray)):</span>
                <span class="s1">rv.status = status</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">rv.status_code = status</span>

        <span class="s0"># extend existing headers with provided headers</span>
        <span class="s2">if </span><span class="s1">headers:</span>
            <span class="s1">rv.headers.extend(headers)</span>

        <span class="s2">return </span><span class="s1">rv</span>

    <span class="s2">def </span><span class="s1">create_url_adapter(self, request):</span>
        <span class="s0">&quot;&quot;&quot;Creates a URL adapter for the given request. The URL adapter 
        is created at a point where the request context is not yet set 
        up so the request is passed explicitly. 
 
        .. versionadded:: 0.6 
 
        .. versionchanged:: 0.9 
           This can now also be called without a request object when the 
           URL adapter is created for the application context. 
 
        .. versionchanged:: 1.0 
            :data:`SERVER_NAME` no longer implicitly enables subdomain 
            matching. Use :attr:`subdomain_matching` instead. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">request </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s0"># If subdomain matching is disabled (the default), use the</span>
            <span class="s0"># default subdomain in all cases. This should be the default</span>
            <span class="s0"># in Werkzeug but it currently does not have that feature.</span>
            <span class="s1">subdomain = (</span>
                <span class="s1">(self.url_map.default_subdomain </span><span class="s2">or None</span><span class="s1">)</span>
                <span class="s2">if not </span><span class="s1">self.subdomain_matching</span>
                <span class="s2">else None</span>
            <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">self.url_map.bind_to_environ(</span>
                <span class="s1">request.environ,</span>
                <span class="s1">server_name=self.config[</span><span class="s3">&quot;SERVER_NAME&quot;</span><span class="s1">],</span>
                <span class="s1">subdomain=subdomain,</span>
            <span class="s1">)</span>
        <span class="s0"># We need at the very least the server name to be set for this</span>
        <span class="s0"># to work.</span>
        <span class="s2">if </span><span class="s1">self.config[</span><span class="s3">&quot;SERVER_NAME&quot;</span><span class="s1">] </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.url_map.bind(</span>
                <span class="s1">self.config[</span><span class="s3">&quot;SERVER_NAME&quot;</span><span class="s1">],</span>
                <span class="s1">script_name=self.config[</span><span class="s3">&quot;APPLICATION_ROOT&quot;</span><span class="s1">],</span>
                <span class="s1">url_scheme=self.config[</span><span class="s3">&quot;PREFERRED_URL_SCHEME&quot;</span><span class="s1">],</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">inject_url_defaults(self, endpoint, values):</span>
        <span class="s0">&quot;&quot;&quot;Injects the URL defaults for the given endpoint directly into 
        the values dictionary passed.  This is used internally and 
        automatically called on URL building. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">funcs = self.url_default_functions.get(</span><span class="s2">None</span><span class="s1">, ())</span>
        <span class="s2">if </span><span class="s3">&quot;.&quot; </span><span class="s2">in </span><span class="s1">endpoint:</span>
            <span class="s1">bp = endpoint.rsplit(</span><span class="s3">&quot;.&quot;</span><span class="s1">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">funcs = chain(funcs, self.url_default_functions.get(bp, ()))</span>
        <span class="s2">for </span><span class="s1">func </span><span class="s2">in </span><span class="s1">funcs:</span>
            <span class="s1">func(endpoint, values)</span>

    <span class="s2">def </span><span class="s1">handle_url_build_error(self, error, endpoint, values):</span>
        <span class="s0">&quot;&quot;&quot;Handle :class:`~werkzeug.routing.BuildError` on :meth:`url_for`. 
        &quot;&quot;&quot;</span>
        <span class="s1">exc_type, exc_value, tb = sys.exc_info()</span>
        <span class="s2">for </span><span class="s1">handler </span><span class="s2">in </span><span class="s1">self.url_build_error_handlers:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">rv = handler(error, endpoint, values)</span>
                <span class="s2">if </span><span class="s1">rv </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">rv</span>
            <span class="s2">except </span><span class="s1">BuildError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s0"># make error available outside except block (py3)</span>
                <span class="s1">error = e</span>

        <span class="s0"># At this point we want to reraise the exception.  If the error is</span>
        <span class="s0"># still the same one we can reraise it with the original traceback,</span>
        <span class="s0"># otherwise we raise it from here.</span>
        <span class="s2">if </span><span class="s1">error </span><span class="s2">is </span><span class="s1">exc_value:</span>
            <span class="s1">reraise(exc_type, exc_value, tb)</span>
        <span class="s2">raise </span><span class="s1">error</span>

    <span class="s2">def </span><span class="s1">preprocess_request(self):</span>
        <span class="s0">&quot;&quot;&quot;Called before the request is dispatched. Calls 
        :attr:`url_value_preprocessors` registered with the app and the 
        current blueprint (if any). Then calls :attr:`before_request_funcs` 
        registered with the app and the blueprint. 
 
        If any :meth:`before_request` handler returns a non-None value, the 
        value is handled as if it was the return value from the view, and 
        further request handling is stopped. 
        &quot;&quot;&quot;</span>

        <span class="s1">bp = _request_ctx_stack.top.request.blueprint</span>

        <span class="s1">funcs = self.url_value_preprocessors.get(</span><span class="s2">None</span><span class="s1">, ())</span>
        <span class="s2">if </span><span class="s1">bp </span><span class="s2">is not None and </span><span class="s1">bp </span><span class="s2">in </span><span class="s1">self.url_value_preprocessors:</span>
            <span class="s1">funcs = chain(funcs, self.url_value_preprocessors[bp])</span>
        <span class="s2">for </span><span class="s1">func </span><span class="s2">in </span><span class="s1">funcs:</span>
            <span class="s1">func(request.endpoint, request.view_args)</span>

        <span class="s1">funcs = self.before_request_funcs.get(</span><span class="s2">None</span><span class="s1">, ())</span>
        <span class="s2">if </span><span class="s1">bp </span><span class="s2">is not None and </span><span class="s1">bp </span><span class="s2">in </span><span class="s1">self.before_request_funcs:</span>
            <span class="s1">funcs = chain(funcs, self.before_request_funcs[bp])</span>
        <span class="s2">for </span><span class="s1">func </span><span class="s2">in </span><span class="s1">funcs:</span>
            <span class="s1">rv = func()</span>
            <span class="s2">if </span><span class="s1">rv </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">rv</span>

    <span class="s2">def </span><span class="s1">process_response(self, response):</span>
        <span class="s0">&quot;&quot;&quot;Can be overridden in order to modify the response object 
        before it's sent to the WSGI server.  By default this will 
        call all the :meth:`after_request` decorated functions. 
 
        .. versionchanged:: 0.5 
           As of Flask 0.5 the functions registered for after request 
           execution are called in reverse order of registration. 
 
        :param response: a :attr:`response_class` object. 
        :return: a new response object or the same, has to be an 
                 instance of :attr:`response_class`. 
        &quot;&quot;&quot;</span>
        <span class="s1">ctx = _request_ctx_stack.top</span>
        <span class="s1">bp = ctx.request.blueprint</span>
        <span class="s1">funcs = ctx._after_request_functions</span>
        <span class="s2">if </span><span class="s1">bp </span><span class="s2">is not None and </span><span class="s1">bp </span><span class="s2">in </span><span class="s1">self.after_request_funcs:</span>
            <span class="s1">funcs = chain(funcs, reversed(self.after_request_funcs[bp]))</span>
        <span class="s2">if None in </span><span class="s1">self.after_request_funcs:</span>
            <span class="s1">funcs = chain(funcs, reversed(self.after_request_funcs[</span><span class="s2">None</span><span class="s1">]))</span>
        <span class="s2">for </span><span class="s1">handler </span><span class="s2">in </span><span class="s1">funcs:</span>
            <span class="s1">response = handler(response)</span>
        <span class="s2">if not </span><span class="s1">self.session_interface.is_null_session(ctx.session):</span>
            <span class="s1">self.session_interface.save_session(self, ctx.session, response)</span>
        <span class="s2">return </span><span class="s1">response</span>

    <span class="s2">def </span><span class="s1">do_teardown_request(self, exc=_sentinel):</span>
        <span class="s0">&quot;&quot;&quot;Called after the request is dispatched and the response is 
        returned, right before the request context is popped. 
 
        This calls all functions decorated with 
        :meth:`teardown_request`, and :meth:`Blueprint.teardown_request` 
        if a blueprint handled the request. Finally, the 
        :data:`request_tearing_down` signal is sent. 
 
        This is called by 
        :meth:`RequestContext.pop() &lt;flask.ctx.RequestContext.pop&gt;`, 
        which may be delayed during testing to maintain access to 
        resources. 
 
        :param exc: An unhandled exception raised while dispatching the 
            request. Detected from the current exception information if 
            not passed. Passed to each teardown function. 
 
        .. versionchanged:: 0.9 
            Added the ``exc`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">exc </span><span class="s2">is </span><span class="s1">_sentinel:</span>
            <span class="s1">exc = sys.exc_info()[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">funcs = reversed(self.teardown_request_funcs.get(</span><span class="s2">None</span><span class="s1">, ()))</span>
        <span class="s1">bp = _request_ctx_stack.top.request.blueprint</span>
        <span class="s2">if </span><span class="s1">bp </span><span class="s2">is not None and </span><span class="s1">bp </span><span class="s2">in </span><span class="s1">self.teardown_request_funcs:</span>
            <span class="s1">funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))</span>
        <span class="s2">for </span><span class="s1">func </span><span class="s2">in </span><span class="s1">funcs:</span>
            <span class="s1">func(exc)</span>
        <span class="s1">request_tearing_down.send(self, exc=exc)</span>

    <span class="s2">def </span><span class="s1">do_teardown_appcontext(self, exc=_sentinel):</span>
        <span class="s0">&quot;&quot;&quot;Called right before the application context is popped. 
 
        When handling a request, the application context is popped 
        after the request context. See :meth:`do_teardown_request`. 
 
        This calls all functions decorated with 
        :meth:`teardown_appcontext`. Then the 
        :data:`appcontext_tearing_down` signal is sent. 
 
        This is called by 
        :meth:`AppContext.pop() &lt;flask.ctx.AppContext.pop&gt;`. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">exc </span><span class="s2">is </span><span class="s1">_sentinel:</span>
            <span class="s1">exc = sys.exc_info()[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">func </span><span class="s2">in </span><span class="s1">reversed(self.teardown_appcontext_funcs):</span>
            <span class="s1">func(exc)</span>
        <span class="s1">appcontext_tearing_down.send(self, exc=exc)</span>

    <span class="s2">def </span><span class="s1">app_context(self):</span>
        <span class="s0">&quot;&quot;&quot;Create an :class:`~flask.ctx.AppContext`. Use as a ``with`` 
        block to push the context, which will make :data:`current_app` 
        point at this application. 
 
        An application context is automatically pushed by 
        :meth:`RequestContext.push() &lt;flask.ctx.RequestContext.push&gt;` 
        when handling a request, and when running a CLI command. Use 
        this to manually create a context outside of these situations. 
 
        :: 
 
            with app.app_context(): 
                init_db() 
 
        See :doc:`/appcontext`. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">AppContext(self)</span>

    <span class="s2">def </span><span class="s1">request_context(self, environ):</span>
        <span class="s0">&quot;&quot;&quot;Create a :class:`~flask.ctx.RequestContext` representing a 
        WSGI environment. Use a ``with`` block to push the context, 
        which will make :data:`request` point at this request. 
 
        See :doc:`/reqcontext`. 
 
        Typically you should not call this from your own code. A request 
        context is automatically pushed by the :meth:`wsgi_app` when 
        handling a request. Use :meth:`test_request_context` to create 
        an environment and context instead of this method. 
 
        :param environ: a WSGI environment 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">RequestContext(self, environ)</span>

    <span class="s2">def </span><span class="s1">test_request_context(self, *args, **kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Create a :class:`~flask.ctx.RequestContext` for a WSGI 
        environment created from the given values. This is mostly useful 
        during testing, where you may want to run a function that uses 
        request data without dispatching a full request. 
 
        See :doc:`/reqcontext`. 
 
        Use a ``with`` block to push the context, which will make 
        :data:`request` point at the request for the created 
        environment. :: 
 
            with test_request_context(...): 
                generate_report() 
 
        When using the shell, it may be easier to push and pop the 
        context manually to avoid indentation. :: 
 
            ctx = app.test_request_context(...) 
            ctx.push() 
            ... 
            ctx.pop() 
 
        Takes the same arguments as Werkzeug's 
        :class:`~werkzeug.test.EnvironBuilder`, with some defaults from 
        the application. See the linked Werkzeug docs for most of the 
        available arguments. Flask-specific behavior is listed here. 
 
        :param path: URL path being requested. 
        :param base_url: Base URL where the app is being served, which 
            ``path`` is relative to. If not given, built from 
            :data:`PREFERRED_URL_SCHEME`, ``subdomain``, 
            :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`. 
        :param subdomain: Subdomain name to append to 
            :data:`SERVER_NAME`. 
        :param url_scheme: Scheme to use instead of 
            :data:`PREFERRED_URL_SCHEME`. 
        :param data: The request body, either as a string or a dict of 
            form keys and values. 
        :param json: If given, this is serialized as JSON and passed as 
            ``data``. Also defaults ``content_type`` to 
            ``application/json``. 
        :param args: other positional arguments passed to 
            :class:`~werkzeug.test.EnvironBuilder`. 
        :param kwargs: other keyword arguments passed to 
            :class:`~werkzeug.test.EnvironBuilder`. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">.testing </span><span class="s2">import </span><span class="s1">EnvironBuilder</span>

        <span class="s1">builder = EnvironBuilder(self, *args, **kwargs)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.request_context(builder.get_environ())</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">builder.close()</span>

    <span class="s2">def </span><span class="s1">wsgi_app(self, environ, start_response):</span>
        <span class="s0">&quot;&quot;&quot;The actual WSGI application. This is not implemented in 
        :meth:`__call__` so that middlewares can be applied without 
        losing a reference to the app object. Instead of doing this:: 
 
            app = MyMiddleware(app) 
 
        It's a better idea to do this instead:: 
 
            app.wsgi_app = MyMiddleware(app.wsgi_app) 
 
        Then you still have the original application object around and 
        can continue to call methods on it. 
 
        .. versionchanged:: 0.7 
            Teardown events for the request and app contexts are called 
            even if an unhandled error occurs. Other events may not be 
            called depending on when an error occurs during dispatch. 
            See :ref:`callbacks-and-errors`. 
 
        :param environ: A WSGI environment. 
        :param start_response: A callable accepting a status code, 
            a list of headers, and an optional exception context to 
            start the response. 
        &quot;&quot;&quot;</span>
        <span class="s1">ctx = self.request_context(environ)</span>
        <span class="s1">error = </span><span class="s2">None</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">ctx.push()</span>
                <span class="s1">response = self.full_dispatch_request()</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">error = e</span>
                <span class="s1">response = self.handle_exception(e)</span>
            <span class="s2">except</span><span class="s1">:  </span><span class="s0"># noqa: B001</span>
                <span class="s1">error = sys.exc_info()[</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s2">raise</span>
            <span class="s2">return </span><span class="s1">response(environ, start_response)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.should_ignore_error(error):</span>
                <span class="s1">error = </span><span class="s2">None</span>
            <span class="s1">ctx.auto_pop(error)</span>

    <span class="s2">def </span><span class="s1">__call__(self, environ, start_response):</span>
        <span class="s0">&quot;&quot;&quot;The WSGI server calls the Flask application object as the 
        WSGI application. This calls :meth:`wsgi_app` which can be 
        wrapped to applying middleware.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.wsgi_app(environ, start_response)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;%s %r&gt;&quot; </span><span class="s1">% (self.__class__.__name__, self.name)</span>
</pre>
</body>
</html>