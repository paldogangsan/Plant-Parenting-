<html>
<head>
<title>base_request.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #067d17;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
base_request.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">update_wrapper</span>
<span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">BytesIO</span>

<span class="s0">from </span><span class="s1">.._compat </span><span class="s0">import </span><span class="s1">to_native</span>
<span class="s0">from </span><span class="s1">.._compat </span><span class="s0">import </span><span class="s1">to_unicode</span>
<span class="s0">from </span><span class="s1">.._compat </span><span class="s0">import </span><span class="s1">wsgi_decoding_dance</span>
<span class="s0">from </span><span class="s1">.._compat </span><span class="s0">import </span><span class="s1">wsgi_get_bytes</span>
<span class="s0">from </span><span class="s1">..datastructures </span><span class="s0">import </span><span class="s1">CombinedMultiDict</span>
<span class="s0">from </span><span class="s1">..datastructures </span><span class="s0">import </span><span class="s1">EnvironHeaders</span>
<span class="s0">from </span><span class="s1">..datastructures </span><span class="s0">import </span><span class="s1">ImmutableList</span>
<span class="s0">from </span><span class="s1">..datastructures </span><span class="s0">import </span><span class="s1">ImmutableMultiDict</span>
<span class="s0">from </span><span class="s1">..datastructures </span><span class="s0">import </span><span class="s1">iter_multi_items</span>
<span class="s0">from </span><span class="s1">..datastructures </span><span class="s0">import </span><span class="s1">MultiDict</span>
<span class="s0">from </span><span class="s1">..formparser </span><span class="s0">import </span><span class="s1">default_stream_factory</span>
<span class="s0">from </span><span class="s1">..formparser </span><span class="s0">import </span><span class="s1">FormDataParser</span>
<span class="s0">from </span><span class="s1">..http </span><span class="s0">import </span><span class="s1">parse_cookie</span>
<span class="s0">from </span><span class="s1">..http </span><span class="s0">import </span><span class="s1">parse_list_header</span>
<span class="s0">from </span><span class="s1">..http </span><span class="s0">import </span><span class="s1">parse_options_header</span>
<span class="s0">from </span><span class="s1">..urls </span><span class="s0">import </span><span class="s1">url_decode</span>
<span class="s0">from </span><span class="s1">..utils </span><span class="s0">import </span><span class="s1">cached_property</span>
<span class="s0">from </span><span class="s1">..utils </span><span class="s0">import </span><span class="s1">environ_property</span>
<span class="s0">from </span><span class="s1">..wsgi </span><span class="s0">import </span><span class="s1">get_content_length</span>
<span class="s0">from </span><span class="s1">..wsgi </span><span class="s0">import </span><span class="s1">get_current_url</span>
<span class="s0">from </span><span class="s1">..wsgi </span><span class="s0">import </span><span class="s1">get_host</span>
<span class="s0">from </span><span class="s1">..wsgi </span><span class="s0">import </span><span class="s1">get_input_stream</span>


<span class="s0">class </span><span class="s1">BaseRequest(object):</span>
    <span class="s2">&quot;&quot;&quot;Very basic request object.  This does not implement advanced stuff like 
    entity tag parsing or cache controls.  The request object is created with 
    the WSGI environment as first argument and will add itself to the WSGI 
    environment as ``'werkzeug.request'`` unless it's created with 
    `populate_request` set to False. 
 
    There are a couple of mixins available that add additional functionality 
    to the request object, there is also a class called `Request` which 
    subclasses `BaseRequest` and all the important mixins. 
 
    It's a good idea to create a custom subclass of the :class:`BaseRequest` 
    and add missing functionality either via mixins or direct implementation. 
    Here an example for such subclasses:: 
 
        from werkzeug.wrappers import BaseRequest, ETagRequestMixin 
 
        class Request(BaseRequest, ETagRequestMixin): 
            pass 
 
    Request objects are **read only**.  As of 0.5 modifications are not 
    allowed in any place.  Unlike the lower level parsing functions the 
    request object will use immutable objects everywhere possible. 
 
    Per default the request object will assume all the text data is `utf-8` 
    encoded.  Please refer to :doc:`the unicode chapter &lt;/unicode&gt;` for more 
    details about customizing the behavior. 
 
    Per default the request object will be added to the WSGI 
    environment as `werkzeug.request` to support the debugging system. 
    If you don't want that, set `populate_request` to `False`. 
 
    If `shallow` is `True` the environment is initialized as shallow 
    object around the environ.  Every operation that would modify the 
    environ in any way (such as consuming form data) raises an exception 
    unless the `shallow` attribute is explicitly set to `False`.  This 
    is useful for middlewares where you don't want to consume the form 
    data by accident.  A shallow request is not populated to the WSGI 
    environment. 
 
    .. versionchanged:: 0.5 
       read-only mode was enforced by using immutables classes for all 
       data. 
    &quot;&quot;&quot;</span>

    <span class="s2">#: the charset for the request, defaults to utf-8</span>
    <span class="s1">charset = </span><span class="s3">&quot;utf-8&quot;</span>

    <span class="s2">#: the error handling procedure for errors, defaults to 'replace'</span>
    <span class="s1">encoding_errors = </span><span class="s3">&quot;replace&quot;</span>

    <span class="s2">#: the maximum content length.  This is forwarded to the form data</span>
    <span class="s2">#: parsing function (:func:`parse_form_data`).  When set and the</span>
    <span class="s2">#: :attr:`form` or :attr:`files` attribute is accessed and the</span>
    <span class="s2">#: parsing fails because more than the specified value is transmitted</span>
    <span class="s2">#: a :exc:`~werkzeug.exceptions.RequestEntityTooLarge` exception is raised.</span>
    <span class="s2">#:</span>
    <span class="s2">#: Have a look at :ref:`dealing-with-request-data` for more details.</span>
    <span class="s2">#:</span>
    <span class="s2">#: .. versionadded:: 0.5</span>
    <span class="s1">max_content_length = </span><span class="s0">None</span>

    <span class="s2">#: the maximum form field size.  This is forwarded to the form data</span>
    <span class="s2">#: parsing function (:func:`parse_form_data`).  When set and the</span>
    <span class="s2">#: :attr:`form` or :attr:`files` attribute is accessed and the</span>
    <span class="s2">#: data in memory for post data is longer than the specified value a</span>
    <span class="s2">#: :exc:`~werkzeug.exceptions.RequestEntityTooLarge` exception is raised.</span>
    <span class="s2">#:</span>
    <span class="s2">#: Have a look at :ref:`dealing-with-request-data` for more details.</span>
    <span class="s2">#:</span>
    <span class="s2">#: .. versionadded:: 0.5</span>
    <span class="s1">max_form_memory_size = </span><span class="s0">None</span>

    <span class="s2">#: the class to use for `args` and `form`.  The default is an</span>
    <span class="s2">#: :class:`~werkzeug.datastructures.ImmutableMultiDict` which supports</span>
    <span class="s2">#: multiple values per key.  alternatively it makes sense to use an</span>
    <span class="s2">#: :class:`~werkzeug.datastructures.ImmutableOrderedMultiDict` which</span>
    <span class="s2">#: preserves order or a :class:`~werkzeug.datastructures.ImmutableDict`</span>
    <span class="s2">#: which is the fastest but only remembers the last key.  It is also</span>
    <span class="s2">#: possible to use mutable structures, but this is not recommended.</span>
    <span class="s2">#:</span>
    <span class="s2">#: .. versionadded:: 0.6</span>
    <span class="s1">parameter_storage_class = ImmutableMultiDict</span>

    <span class="s2">#: the type to be used for list values from the incoming WSGI environment.</span>
    <span class="s2">#: By default an :class:`~werkzeug.datastructures.ImmutableList` is used</span>
    <span class="s2">#: (for example for :attr:`access_list`).</span>
    <span class="s2">#:</span>
    <span class="s2">#: .. versionadded:: 0.6</span>
    <span class="s1">list_storage_class = ImmutableList</span>

    <span class="s2">#: The type to be used for dict values from the incoming WSGI</span>
    <span class="s2">#: environment. (For example for :attr:`cookies`.) By default an</span>
    <span class="s2">#: :class:`~werkzeug.datastructures.ImmutableMultiDict` is used.</span>
    <span class="s2">#:</span>
    <span class="s2">#: .. versionchanged:: 1.0.0</span>
    <span class="s2">#:     Changed to ``ImmutableMultiDict`` to support multiple values.</span>
    <span class="s2">#:</span>
    <span class="s2">#: .. versionadded:: 0.6</span>
    <span class="s1">dict_storage_class = ImmutableMultiDict</span>

    <span class="s2">#: The form data parser that shoud be used.  Can be replaced to customize</span>
    <span class="s2">#: the form date parsing.</span>
    <span class="s1">form_data_parser_class = FormDataParser</span>

    <span class="s2">#: Optionally a list of hosts that is trusted by this request.  By default</span>
    <span class="s2">#: all hosts are trusted which means that whatever the client sends the</span>
    <span class="s2">#: host is will be accepted.</span>
    <span class="s2">#:</span>
    <span class="s2">#: Because `Host` and `X-Forwarded-Host` headers can be set to any value by</span>
    <span class="s2">#: a malicious client, it is recommended to either set this property or</span>
    <span class="s2">#: implement similar validation in the proxy (if application is being run</span>
    <span class="s2">#: behind one).</span>
    <span class="s2">#:</span>
    <span class="s2">#: .. versionadded:: 0.9</span>
    <span class="s1">trusted_hosts = </span><span class="s0">None</span>

    <span class="s2">#: Indicates whether the data descriptor should be allowed to read and</span>
    <span class="s2">#: buffer up the input stream.  By default it's enabled.</span>
    <span class="s2">#:</span>
    <span class="s2">#: .. versionadded:: 0.9</span>
    <span class="s1">disable_data_descriptor = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__init__(self, environ, populate_request=</span><span class="s0">True</span><span class="s1">, shallow=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">self.environ = environ</span>
        <span class="s0">if </span><span class="s1">populate_request </span><span class="s0">and not </span><span class="s1">shallow:</span>
            <span class="s1">self.environ[</span><span class="s3">&quot;werkzeug.request&quot;</span><span class="s1">] = self</span>
        <span class="s1">self.shallow = shallow</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s2"># make sure the __repr__ even works if the request was created</span>
        <span class="s2"># from an invalid WSGI environment.  If we display the request</span>
        <span class="s2"># in a debug session we don't want the repr to blow up.</span>
        <span class="s1">args = []</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">args.append(</span><span class="s3">&quot;'%s'&quot; </span><span class="s1">% to_native(self.url, self.url_charset))</span>
            <span class="s1">args.append(</span><span class="s3">&quot;[%s]&quot; </span><span class="s1">% self.method)</span>
        <span class="s0">except </span><span class="s1">Exception:</span>
            <span class="s1">args.append(</span><span class="s3">&quot;(invalid WSGI environ)&quot;</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s3">&quot;&lt;%s %s&gt;&quot; </span><span class="s1">% (self.__class__.__name__, </span><span class="s3">&quot; &quot;</span><span class="s1">.join(args))</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">url_charset(self):</span>
        <span class="s2">&quot;&quot;&quot;The charset that is assumed for URLs.  Defaults to the value 
        of :attr:`charset`. 
 
        .. versionadded:: 0.6 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.charset</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_values(cls, *args, **kwargs):</span>
        <span class="s2">&quot;&quot;&quot;Create a new request object based on the values provided.  If 
        environ is given missing values are filled from there.  This method is 
        useful for small scripts when you need to simulate a request from an URL. 
        Do not use this method for unittesting, there is a full featured client 
        object (:class:`Client`) that allows to create multipart requests, 
        support for cookies etc. 
 
        This accepts the same options as the 
        :class:`~werkzeug.test.EnvironBuilder`. 
 
        .. versionchanged:: 0.5 
           This method now accepts the same arguments as 
           :class:`~werkzeug.test.EnvironBuilder`.  Because of this the 
           `environ` parameter is now called `environ_overrides`. 
 
        :return: request object 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">..test </span><span class="s0">import </span><span class="s1">EnvironBuilder</span>

        <span class="s1">charset = kwargs.pop(</span><span class="s3">&quot;charset&quot;</span><span class="s1">, cls.charset)</span>
        <span class="s1">kwargs[</span><span class="s3">&quot;charset&quot;</span><span class="s1">] = charset</span>
        <span class="s1">builder = EnvironBuilder(*args, **kwargs)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">builder.get_request(cls)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">builder.close()</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">application(cls, f):</span>
        <span class="s2">&quot;&quot;&quot;Decorate a function as responder that accepts the request as 
        the last argument.  This works like the :func:`responder` 
        decorator but the function is passed the request object as the 
        last argument and the request object will be closed 
        automatically:: 
 
            @Request.application 
            def my_wsgi_app(request): 
                return Response('Hello World!') 
 
        As of Werkzeug 0.14 HTTP exceptions are automatically caught and 
        converted to responses instead of failing. 
 
        :param f: the WSGI callable to decorate 
        :return: a new WSGI callable 
        &quot;&quot;&quot;</span>
        <span class="s2">#: return a callable that wraps the -2nd argument with the request</span>
        <span class="s2">#: and calls the function with all the arguments up to that one and</span>
        <span class="s2">#: the request.  The return value is then called with the latest</span>
        <span class="s2">#: two arguments.  This makes it possible to use this decorator for</span>
        <span class="s2">#: both standalone WSGI functions as well as bound methods and</span>
        <span class="s2">#: partially applied functions.</span>
        <span class="s0">from </span><span class="s1">..exceptions </span><span class="s0">import </span><span class="s1">HTTPException</span>

        <span class="s0">def </span><span class="s1">application(*args):</span>
            <span class="s1">request = cls(args[-</span><span class="s4">2</span><span class="s1">])</span>
            <span class="s0">with </span><span class="s1">request:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">resp = f(*args[:-</span><span class="s4">2</span><span class="s1">] + (request,))</span>
                <span class="s0">except </span><span class="s1">HTTPException </span><span class="s0">as </span><span class="s1">e:</span>
                    <span class="s1">resp = e.get_response(args[-</span><span class="s4">2</span><span class="s1">])</span>
                <span class="s0">return </span><span class="s1">resp(*args[-</span><span class="s4">2</span><span class="s1">:])</span>

        <span class="s0">return </span><span class="s1">update_wrapper(application, f)</span>

    <span class="s0">def </span><span class="s1">_get_file_stream(</span>
        <span class="s1">self, total_content_length, content_type, filename=</span><span class="s0">None</span><span class="s1">, content_length=</span><span class="s0">None</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Called to get a stream for the file upload. 
 
        This must provide a file-like class with `read()`, `readline()` 
        and `seek()` methods that is both writeable and readable. 
 
        The default implementation returns a temporary file if the total 
        content length is higher than 500KB.  Because many browsers do not 
        provide a content length for the files only the total content 
        length matters. 
 
        :param total_content_length: the total content length of all the 
                                     data in the request combined.  This value 
                                     is guaranteed to be there. 
        :param content_type: the mimetype of the uploaded file. 
        :param filename: the filename of the uploaded file.  May be `None`. 
        :param content_length: the length of this file.  This value is usually 
                               not provided because webbrowsers do not provide 
                               this value. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">default_stream_factory(</span>
            <span class="s1">total_content_length=total_content_length,</span>
            <span class="s1">filename=filename,</span>
            <span class="s1">content_type=content_type,</span>
            <span class="s1">content_length=content_length,</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">want_form_data_parsed(self):</span>
        <span class="s2">&quot;&quot;&quot;Returns True if the request method carries content.  As of 
        Werkzeug 0.9 this will be the case if a content type is transmitted. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">bool(self.environ.get(</span><span class="s3">&quot;CONTENT_TYPE&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">make_form_data_parser(self):</span>
        <span class="s2">&quot;&quot;&quot;Creates the form data parser. Instantiates the 
        :attr:`form_data_parser_class` with some parameters. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.form_data_parser_class(</span>
            <span class="s1">self._get_file_stream,</span>
            <span class="s1">self.charset,</span>
            <span class="s1">self.encoding_errors,</span>
            <span class="s1">self.max_form_memory_size,</span>
            <span class="s1">self.max_content_length,</span>
            <span class="s1">self.parameter_storage_class,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_load_form_data(self):</span>
        <span class="s2">&quot;&quot;&quot;Method used internally to retrieve submitted data.  After calling 
        this sets `form` and `files` on the request object to multi dicts 
        filled with the incoming form data.  As a matter of fact the input 
        stream will be empty afterwards.  You can also call this method to 
        force the parsing of the form data. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s2"># abort early if we have already consumed the stream</span>
        <span class="s0">if </span><span class="s3">&quot;form&quot; </span><span class="s0">in </span><span class="s1">self.__dict__:</span>
            <span class="s0">return</span>

        <span class="s1">_assert_not_shallow(self)</span>

        <span class="s0">if </span><span class="s1">self.want_form_data_parsed:</span>
            <span class="s1">content_type = self.environ.get(</span><span class="s3">&quot;CONTENT_TYPE&quot;</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">content_length = get_content_length(self.environ)</span>
            <span class="s1">mimetype, options = parse_options_header(content_type)</span>
            <span class="s1">parser = self.make_form_data_parser()</span>
            <span class="s1">data = parser.parse(</span>
                <span class="s1">self._get_stream_for_parsing(), mimetype, content_length, options</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">data = (</span>
                <span class="s1">self.stream,</span>
                <span class="s1">self.parameter_storage_class(),</span>
                <span class="s1">self.parameter_storage_class(),</span>
            <span class="s1">)</span>

        <span class="s2"># inject the values into the instance dict so that we bypass</span>
        <span class="s2"># our cached_property non-data descriptor.</span>
        <span class="s1">d = self.__dict__</span>
        <span class="s1">d[</span><span class="s3">&quot;stream&quot;</span><span class="s1">], d[</span><span class="s3">&quot;form&quot;</span><span class="s1">], d[</span><span class="s3">&quot;files&quot;</span><span class="s1">] = data</span>

    <span class="s0">def </span><span class="s1">_get_stream_for_parsing(self):</span>
        <span class="s2">&quot;&quot;&quot;This is the same as accessing :attr:`stream` with the difference 
        that if it finds cached data from calling :meth:`get_data` first it 
        will create a new stream out of the cached data. 
 
        .. versionadded:: 0.9.3 
        &quot;&quot;&quot;</span>
        <span class="s1">cached_data = getattr(self, </span><span class="s3">&quot;_cached_data&quot;</span><span class="s1">, </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">cached_data </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">BytesIO(cached_data)</span>
        <span class="s0">return </span><span class="s1">self.stream</span>

    <span class="s0">def </span><span class="s1">close(self):</span>
        <span class="s2">&quot;&quot;&quot;Closes associated resources of this request object.  This 
        closes all file handles explicitly.  You can also use the request 
        object in a with statement which will automatically close it. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s1">files = self.__dict__.get(</span><span class="s3">&quot;files&quot;</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">_key, value </span><span class="s0">in </span><span class="s1">iter_multi_items(files </span><span class="s0">or </span><span class="s1">()):</span>
            <span class="s1">value.close()</span>

    <span class="s0">def </span><span class="s1">__enter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(self, exc_type, exc_value, tb):</span>
        <span class="s1">self.close()</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">stream(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        If the incoming form data was not encoded with a known mimetype 
        the data is stored unmodified in this stream for consumption.  Most 
        of the time it is a better idea to use :attr:`data` which will give 
        you that data as a string.  The stream only returns the data once. 
 
        Unlike :attr:`input_stream` this stream is properly guarded that you 
        can't accidentally read past the length of the input.  Werkzeug will 
        internally always refer to this stream to read data which makes it 
        possible to wrap this object with a stream that does filtering. 
 
        .. versionchanged:: 0.9 
           This stream is now always available but might be consumed by the 
           form parser later on.  Previously the stream was only set if no 
           parsing happened. 
        &quot;&quot;&quot;</span>
        <span class="s1">_assert_not_shallow(self)</span>
        <span class="s0">return </span><span class="s1">get_input_stream(self.environ)</span>

    <span class="s1">input_stream = environ_property(</span>
        <span class="s3">&quot;wsgi.input&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;&quot;&quot;The WSGI input stream. 
 
        In general it's a bad idea to use this one because you can 
        easily read past the boundary.  Use the :attr:`stream` 
        instead.&quot;&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">args(self):</span>
        <span class="s2">&quot;&quot;&quot;The parsed URL parameters (the part in the URL after the question 
        mark). 
 
        By default an 
        :class:`~werkzeug.datastructures.ImmutableMultiDict` 
        is returned from this function.  This can be changed by setting 
        :attr:`parameter_storage_class` to a different type.  This might 
        be necessary if the order of the form data is important. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">url_decode(</span>
            <span class="s1">wsgi_get_bytes(self.environ.get(</span><span class="s3">&quot;QUERY_STRING&quot;</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">)),</span>
            <span class="s1">self.url_charset,</span>
            <span class="s1">errors=self.encoding_errors,</span>
            <span class="s1">cls=self.parameter_storage_class,</span>
        <span class="s1">)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">data(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Contains the incoming request data as string in case it came with 
        a mimetype Werkzeug does not handle. 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">self.disable_data_descriptor:</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;data descriptor is disabled&quot;</span><span class="s1">)</span>
        <span class="s2"># XXX: this should eventually be deprecated.</span>

        <span class="s2"># We trigger form data parsing first which means that the descriptor</span>
        <span class="s2"># will not cache the data that would otherwise be .form or .files</span>
        <span class="s2"># data.  This restores the behavior that was there in Werkzeug</span>
        <span class="s2"># before 0.9.  New code should use :meth:`get_data` explicitly as</span>
        <span class="s2"># this will make behavior explicit.</span>
        <span class="s0">return </span><span class="s1">self.get_data(parse_form_data=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_data(self, cache=</span><span class="s0">True</span><span class="s1">, as_text=</span><span class="s0">False</span><span class="s1">, parse_form_data=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;This reads the buffered incoming data from the client into one 
        bytestring.  By default this is cached but that behavior can be 
        changed by setting `cache` to `False`. 
 
        Usually it's a bad idea to call this method without checking the 
        content length first as a client could send dozens of megabytes or more 
        to cause memory problems on the server. 
 
        Note that if the form data was already parsed this method will not 
        return anything as form data parsing does not cache the data like 
        this method does.  To implicitly invoke form data parsing function 
        set `parse_form_data` to `True`.  When this is done the return value 
        of this method will be an empty string if the form parser handles 
        the data.  This generally is not necessary as if the whole data is 
        cached (which is the default) the form parser will used the cached 
        data to parse the form data.  Please be generally aware of checking 
        the content length first in any case before calling this method 
        to avoid exhausting server memory. 
 
        If `as_text` is set to `True` the return value will be a decoded 
        unicode string. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = getattr(self, </span><span class="s3">&quot;_cached_data&quot;</span><span class="s1">, </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">rv </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">parse_form_data:</span>
                <span class="s1">self._load_form_data()</span>
            <span class="s1">rv = self.stream.read()</span>
            <span class="s0">if </span><span class="s1">cache:</span>
                <span class="s1">self._cached_data = rv</span>
        <span class="s0">if </span><span class="s1">as_text:</span>
            <span class="s1">rv = rv.decode(self.charset, self.encoding_errors)</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">form(self):</span>
        <span class="s2">&quot;&quot;&quot;The form parameters.  By default an 
        :class:`~werkzeug.datastructures.ImmutableMultiDict` 
        is returned from this function.  This can be changed by setting 
        :attr:`parameter_storage_class` to a different type.  This might 
        be necessary if the order of the form data is important. 
 
        Please keep in mind that file uploads will not end up here, but instead 
        in the :attr:`files` attribute. 
 
        .. versionchanged:: 0.9 
 
            Previous to Werkzeug 0.9 this would only contain form data for POST 
            and PUT requests. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._load_form_data()</span>
        <span class="s0">return </span><span class="s1">self.form</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">values(self):</span>
        <span class="s2">&quot;&quot;&quot;A :class:`werkzeug.datastructures.CombinedMultiDict` that combines 
        :attr:`args` and :attr:`form`.&quot;&quot;&quot;</span>
        <span class="s1">args = []</span>
        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">self.args, self.form:</span>
            <span class="s0">if not </span><span class="s1">isinstance(d, MultiDict):</span>
                <span class="s1">d = MultiDict(d)</span>
            <span class="s1">args.append(d)</span>
        <span class="s0">return </span><span class="s1">CombinedMultiDict(args)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">files(self):</span>
        <span class="s2">&quot;&quot;&quot;:class:`~werkzeug.datastructures.MultiDict` object containing 
        all uploaded files.  Each key in :attr:`files` is the name from the 
        ``&lt;input type=&quot;file&quot; name=&quot;&quot;&gt;``.  Each value in :attr:`files` is a 
        Werkzeug :class:`~werkzeug.datastructures.FileStorage` object. 
 
        It basically behaves like a standard file object you know from Python, 
        with the difference that it also has a 
        :meth:`~werkzeug.datastructures.FileStorage.save` function that can 
        store the file on the filesystem. 
 
        Note that :attr:`files` will only contain data if the request method was 
        POST, PUT or PATCH and the ``&lt;form&gt;`` that posted to the request had 
        ``enctype=&quot;multipart/form-data&quot;``.  It will be empty otherwise. 
 
        See the :class:`~werkzeug.datastructures.MultiDict` / 
        :class:`~werkzeug.datastructures.FileStorage` documentation for 
        more details about the used data structure. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._load_form_data()</span>
        <span class="s0">return </span><span class="s1">self.files</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">cookies(self):</span>
        <span class="s2">&quot;&quot;&quot;A :class:`dict` with the contents of all cookies transmitted with 
        the request.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">parse_cookie(</span>
            <span class="s1">self.environ,</span>
            <span class="s1">self.charset,</span>
            <span class="s1">self.encoding_errors,</span>
            <span class="s1">cls=self.dict_storage_class,</span>
        <span class="s1">)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">headers(self):</span>
        <span class="s2">&quot;&quot;&quot;The headers from the WSGI environ as immutable 
        :class:`~werkzeug.datastructures.EnvironHeaders`. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">EnvironHeaders(self.environ)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">path(self):</span>
        <span class="s2">&quot;&quot;&quot;Requested path as unicode.  This works a bit like the regular path 
        info in the WSGI environment but will always include a leading slash, 
        even if the URL root is accessed. 
        &quot;&quot;&quot;</span>
        <span class="s1">raw_path = wsgi_decoding_dance(</span>
            <span class="s1">self.environ.get(</span><span class="s3">&quot;PATH_INFO&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s3">&quot;&quot;</span><span class="s1">, self.charset, self.encoding_errors</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s3">&quot;/&quot; </span><span class="s1">+ raw_path.lstrip(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">full_path(self):</span>
        <span class="s2">&quot;&quot;&quot;Requested path as unicode, including the query string.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.path + </span><span class="s3">u&quot;?&quot; </span><span class="s1">+ to_unicode(self.query_string, self.url_charset)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">script_root(self):</span>
        <span class="s2">&quot;&quot;&quot;The root path of the script without the trailing slash.&quot;&quot;&quot;</span>
        <span class="s1">raw_path = wsgi_decoding_dance(</span>
            <span class="s1">self.environ.get(</span><span class="s3">&quot;SCRIPT_NAME&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s3">&quot;&quot;</span><span class="s1">, self.charset, self.encoding_errors</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">raw_path.rstrip(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">url(self):</span>
        <span class="s2">&quot;&quot;&quot;The reconstructed current URL as IRI. 
        See also: :attr:`trusted_hosts`. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">get_current_url(self.environ, trusted_hosts=self.trusted_hosts)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">base_url(self):</span>
        <span class="s2">&quot;&quot;&quot;Like :attr:`url` but without the querystring 
        See also: :attr:`trusted_hosts`. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">get_current_url(</span>
            <span class="s1">self.environ, strip_querystring=</span><span class="s0">True</span><span class="s1">, trusted_hosts=self.trusted_hosts</span>
        <span class="s1">)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">url_root(self):</span>
        <span class="s2">&quot;&quot;&quot;The full URL root (with hostname), this is the application 
        root as IRI. 
        See also: :attr:`trusted_hosts`. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">get_current_url(self.environ, </span><span class="s0">True</span><span class="s1">, trusted_hosts=self.trusted_hosts)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">host_url(self):</span>
        <span class="s2">&quot;&quot;&quot;Just the host with scheme as IRI. 
        See also: :attr:`trusted_hosts`. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">get_current_url(</span>
            <span class="s1">self.environ, host_only=</span><span class="s0">True</span><span class="s1">, trusted_hosts=self.trusted_hosts</span>
        <span class="s1">)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">host(self):</span>
        <span class="s2">&quot;&quot;&quot;Just the host including the port if available. 
        See also: :attr:`trusted_hosts`. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">get_host(self.environ, trusted_hosts=self.trusted_hosts)</span>

    <span class="s1">query_string = environ_property(</span>
        <span class="s3">&quot;QUERY_STRING&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;&quot;</span><span class="s1">,</span>
        <span class="s1">read_only=</span><span class="s0">True</span><span class="s1">,</span>
        <span class="s1">load_func=wsgi_get_bytes,</span>
        <span class="s1">doc=</span><span class="s3">&quot;The URL parameters as raw bytestring.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">method = environ_property(</span>
        <span class="s3">&quot;REQUEST_METHOD&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;GET&quot;</span><span class="s1">,</span>
        <span class="s1">read_only=</span><span class="s0">True</span><span class="s1">,</span>
        <span class="s1">load_func=</span><span class="s0">lambda </span><span class="s1">x: x.upper(),</span>
        <span class="s1">doc=</span><span class="s3">&quot;The request method. (For example ``'GET'`` or ``'POST'``).&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">access_route(self):</span>
        <span class="s2">&quot;&quot;&quot;If a forwarded header exists this is a list of all ip addresses 
        from the client ip to the last proxy server. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s3">&quot;HTTP_X_FORWARDED_FOR&quot; </span><span class="s0">in </span><span class="s1">self.environ:</span>
            <span class="s0">return </span><span class="s1">self.list_storage_class(</span>
                <span class="s1">parse_list_header(self.environ[</span><span class="s3">&quot;HTTP_X_FORWARDED_FOR&quot;</span><span class="s1">])</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s3">&quot;REMOTE_ADDR&quot; </span><span class="s0">in </span><span class="s1">self.environ:</span>
            <span class="s0">return </span><span class="s1">self.list_storage_class([self.environ[</span><span class="s3">&quot;REMOTE_ADDR&quot;</span><span class="s1">]])</span>
        <span class="s0">return </span><span class="s1">self.list_storage_class()</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">remote_addr(self):</span>
        <span class="s2">&quot;&quot;&quot;The remote address of the client.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.environ.get(</span><span class="s3">&quot;REMOTE_ADDR&quot;</span><span class="s1">)</span>

    <span class="s1">remote_user = environ_property(</span>
        <span class="s3">&quot;REMOTE_USER&quot;</span><span class="s1">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;If the server supports user authentication, and the 
        script is protected, this attribute contains the username the 
        user has authenticated as.&quot;&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">scheme = environ_property(</span>
        <span class="s3">&quot;wsgi.url_scheme&quot;</span><span class="s1">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot; 
        URL scheme (http or https). 
 
        .. versionadded:: 0.7&quot;&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">is_secure = property(</span>
        <span class="s0">lambda </span><span class="s1">self: self.environ[</span><span class="s3">&quot;wsgi.url_scheme&quot;</span><span class="s1">] == </span><span class="s3">&quot;https&quot;</span><span class="s1">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;`True` if the request is secure.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">is_multithread = environ_property(</span>
        <span class="s3">&quot;wsgi.multithread&quot;</span><span class="s1">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;boolean that is `True` if the application is served by a 
        multithreaded WSGI server.&quot;&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">is_multiprocess = environ_property(</span>
        <span class="s3">&quot;wsgi.multiprocess&quot;</span><span class="s1">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;boolean that is `True` if the application is served by a 
        WSGI server that spawns multiple processes.&quot;&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">is_run_once = environ_property(</span>
        <span class="s3">&quot;wsgi.run_once&quot;</span><span class="s1">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;boolean that is `True` if the application will be 
        executed only once in a process lifetime.  This is the case for 
        CGI for example, but it's not guaranteed that the execution only 
        happens one time.&quot;&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_assert_not_shallow(request):</span>
    <span class="s0">if </span><span class="s1">request.shallow:</span>
        <span class="s0">raise </span><span class="s1">RuntimeError(</span>
            <span class="s3">&quot;A shallow request tried to consume form data. If you really&quot;</span>
            <span class="s3">&quot; want to do that, set `shallow` to False.&quot;</span>
        <span class="s1">)</span>
</pre>
</body>
</html>