<html>
<head>
<title>bdist_egg.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #067d17;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
bdist_egg.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;setuptools.command.bdist_egg 
 
Build .egg distributions&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">DistutilsSetupError</span>
<span class="s2">from </span><span class="s1">distutils.dir_util </span><span class="s2">import </span><span class="s1">remove_tree, mkpath</span>
<span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">log</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">CodeType</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">textwrap</span>
<span class="s2">import </span><span class="s1">marshal</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">from </span><span class="s1">setuptools.extern </span><span class="s2">import </span><span class="s1">six</span>

<span class="s2">from </span><span class="s1">pkg_resources </span><span class="s2">import </span><span class="s1">get_build_platform, Distribution, ensure_directory</span>
<span class="s2">from </span><span class="s1">pkg_resources </span><span class="s2">import </span><span class="s1">EntryPoint</span>
<span class="s2">from </span><span class="s1">setuptools.extension </span><span class="s2">import </span><span class="s1">Library</span>
<span class="s2">from </span><span class="s1">setuptools </span><span class="s2">import </span><span class="s1">Command, SetuptoolsDeprecationWarning</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s0"># Python 2.7 or &gt;=3.2</span>
    <span class="s2">from </span><span class="s1">sysconfig </span><span class="s2">import </span><span class="s1">get_path, get_python_version</span>

    <span class="s2">def </span><span class="s1">_get_purelib():</span>
        <span class="s2">return </span><span class="s1">get_path(</span><span class="s3">&quot;purelib&quot;</span><span class="s1">)</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s2">from </span><span class="s1">distutils.sysconfig </span><span class="s2">import </span><span class="s1">get_python_lib, get_python_version</span>

    <span class="s2">def </span><span class="s1">_get_purelib():</span>
        <span class="s2">return </span><span class="s1">get_python_lib(</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">strip_module(filename):</span>
    <span class="s2">if </span><span class="s3">'.' </span><span class="s2">in </span><span class="s1">filename:</span>
        <span class="s1">filename = os.path.splitext(filename)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">filename.endswith(</span><span class="s3">'module'</span><span class="s1">):</span>
        <span class="s1">filename = filename[:-</span><span class="s4">6</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">filename</span>


<span class="s2">def </span><span class="s1">sorted_walk(dir):</span>
    <span class="s0">&quot;&quot;&quot;Do os.walk in a reproducible way, 
    independent of indeterministic filesystem readdir order 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">base, dirs, files </span><span class="s2">in </span><span class="s1">os.walk(dir):</span>
        <span class="s1">dirs.sort()</span>
        <span class="s1">files.sort()</span>
        <span class="s2">yield </span><span class="s1">base, dirs, files</span>


<span class="s2">def </span><span class="s1">write_stub(resource, pyfile):</span>
    <span class="s1">_stub_template = textwrap.dedent(</span><span class="s3">&quot;&quot;&quot; 
        def __bootstrap__(): 
            global __bootstrap__, __loader__, __file__ 
            import sys, pkg_resources 
            from importlib.machinery import ExtensionFileLoader 
            __file__ = pkg_resources.resource_filename(__name__, %r) 
            __loader__ = None; del __bootstrap__, __loader__ 
            ExtensionFileLoader(__name__,__file__).load_module() 
        __bootstrap__() 
        &quot;&quot;&quot;</span><span class="s1">).lstrip()</span>
    <span class="s2">with </span><span class="s1">open(pyfile, </span><span class="s3">'w'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s1">f.write(_stub_template % resource)</span>


<span class="s2">class </span><span class="s1">bdist_egg(Command):</span>
    <span class="s1">description = </span><span class="s3">&quot;create an </span><span class="s5">\&quot;</span><span class="s3">egg</span><span class="s5">\&quot; </span><span class="s3">distribution&quot;</span>

    <span class="s1">user_options = [</span>
        <span class="s1">(</span><span class="s3">'bdist-dir='</span><span class="s1">, </span><span class="s3">'b'</span><span class="s1">,</span>
         <span class="s3">&quot;temporary directory for creating the distribution&quot;</span><span class="s1">),</span>
        <span class="s1">(</span><span class="s3">'plat-name='</span><span class="s1">, </span><span class="s3">'p'</span><span class="s1">, </span><span class="s3">&quot;platform name to embed in generated filenames &quot;</span>
                            <span class="s3">&quot;(default: %s)&quot; </span><span class="s1">% get_build_platform()),</span>
        <span class="s1">(</span><span class="s3">'exclude-source-files'</span><span class="s1">, </span><span class="s2">None</span><span class="s1">,</span>
         <span class="s3">&quot;remove all .py files from the generated egg&quot;</span><span class="s1">),</span>
        <span class="s1">(</span><span class="s3">'keep-temp'</span><span class="s1">, </span><span class="s3">'k'</span><span class="s1">,</span>
         <span class="s3">&quot;keep the pseudo-installation tree around after &quot; </span><span class="s1">+</span>
         <span class="s3">&quot;creating the distribution archive&quot;</span><span class="s1">),</span>
        <span class="s1">(</span><span class="s3">'dist-dir='</span><span class="s1">, </span><span class="s3">'d'</span><span class="s1">,</span>
         <span class="s3">&quot;directory to put final built distributions in&quot;</span><span class="s1">),</span>
        <span class="s1">(</span><span class="s3">'skip-build'</span><span class="s1">, </span><span class="s2">None</span><span class="s1">,</span>
         <span class="s3">&quot;skip rebuilding everything (for testing/debugging)&quot;</span><span class="s1">),</span>
    <span class="s1">]</span>

    <span class="s1">boolean_options = [</span>
        <span class="s3">'keep-temp'</span><span class="s1">, </span><span class="s3">'skip-build'</span><span class="s1">, </span><span class="s3">'exclude-source-files'</span>
    <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">initialize_options(self):</span>
        <span class="s1">self.bdist_dir = </span><span class="s2">None</span>
        <span class="s1">self.plat_name = </span><span class="s2">None</span>
        <span class="s1">self.keep_temp = </span><span class="s4">0</span>
        <span class="s1">self.dist_dir = </span><span class="s2">None</span>
        <span class="s1">self.skip_build = </span><span class="s4">0</span>
        <span class="s1">self.egg_output = </span><span class="s2">None</span>
        <span class="s1">self.exclude_source_files = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">finalize_options(self):</span>
        <span class="s1">ei_cmd = self.ei_cmd = self.get_finalized_command(</span><span class="s3">&quot;egg_info&quot;</span><span class="s1">)</span>
        <span class="s1">self.egg_info = ei_cmd.egg_info</span>

        <span class="s2">if </span><span class="s1">self.bdist_dir </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">bdist_base = self.get_finalized_command(</span><span class="s3">'bdist'</span><span class="s1">).bdist_base</span>
            <span class="s1">self.bdist_dir = os.path.join(bdist_base, </span><span class="s3">'egg'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.plat_name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.plat_name = get_build_platform()</span>

        <span class="s1">self.set_undefined_options(</span><span class="s3">'bdist'</span><span class="s1">, (</span><span class="s3">'dist_dir'</span><span class="s1">, </span><span class="s3">'dist_dir'</span><span class="s1">))</span>

        <span class="s2">if </span><span class="s1">self.egg_output </span><span class="s2">is None</span><span class="s1">:</span>

            <span class="s0"># Compute filename of the output egg</span>
            <span class="s1">basename = Distribution(</span>
                <span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">, ei_cmd.egg_name, ei_cmd.egg_version,</span>
                <span class="s1">get_python_version(),</span>
                <span class="s1">self.distribution.has_ext_modules() </span><span class="s2">and </span><span class="s1">self.plat_name</span>
            <span class="s1">).egg_name()</span>

            <span class="s1">self.egg_output = os.path.join(self.dist_dir, basename + </span><span class="s3">'.egg'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">do_install_data(self):</span>
        <span class="s0"># Hack for packages that install data to install's --install-lib</span>
        <span class="s1">self.get_finalized_command(</span><span class="s3">'install'</span><span class="s1">).install_lib = self.bdist_dir</span>

        <span class="s1">site_packages = os.path.normcase(os.path.realpath(_get_purelib()))</span>
        <span class="s1">old, self.distribution.data_files = self.distribution.data_files, []</span>

        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">old:</span>
            <span class="s2">if </span><span class="s1">isinstance(item, tuple) </span><span class="s2">and </span><span class="s1">len(item) == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">os.path.isabs(item[</span><span class="s4">0</span><span class="s1">]):</span>
                    <span class="s1">realpath = os.path.realpath(item[</span><span class="s4">0</span><span class="s1">])</span>
                    <span class="s1">normalized = os.path.normcase(realpath)</span>
                    <span class="s2">if </span><span class="s1">normalized == site_packages </span><span class="s2">or </span><span class="s1">normalized.startswith(</span>
                        <span class="s1">site_packages + os.sep</span>
                    <span class="s1">):</span>
                        <span class="s1">item = realpath[len(site_packages) + </span><span class="s4">1</span><span class="s1">:], item[</span><span class="s4">1</span><span class="s1">]</span>
                        <span class="s0"># XXX else: raise ???</span>
            <span class="s1">self.distribution.data_files.append(item)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">log.info(</span><span class="s3">&quot;installing package data to %s&quot;</span><span class="s1">, self.bdist_dir)</span>
            <span class="s1">self.call_command(</span><span class="s3">'install_data'</span><span class="s1">, force=</span><span class="s4">0</span><span class="s1">, root=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self.distribution.data_files = old</span>

    <span class="s2">def </span><span class="s1">get_outputs(self):</span>
        <span class="s2">return </span><span class="s1">[self.egg_output]</span>

    <span class="s2">def </span><span class="s1">call_command(self, cmdname, **kw):</span>
        <span class="s0">&quot;&quot;&quot;Invoke reinitialized command `cmdname` with keyword args&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">dirname </span><span class="s2">in </span><span class="s1">INSTALL_DIRECTORY_ATTRS:</span>
            <span class="s1">kw.setdefault(dirname, self.bdist_dir)</span>
        <span class="s1">kw.setdefault(</span><span class="s3">'skip_build'</span><span class="s1">, self.skip_build)</span>
        <span class="s1">kw.setdefault(</span><span class="s3">'dry_run'</span><span class="s1">, self.dry_run)</span>
        <span class="s1">cmd = self.reinitialize_command(cmdname, **kw)</span>
        <span class="s1">self.run_command(cmdname)</span>
        <span class="s2">return </span><span class="s1">cmd</span>

    <span class="s2">def </span><span class="s1">run(self):</span>
        <span class="s0"># Generate metadata first</span>
        <span class="s1">self.run_command(</span><span class="s3">&quot;egg_info&quot;</span><span class="s1">)</span>
        <span class="s0"># We run install_lib before install_data, because some data hacks</span>
        <span class="s0"># pull their data path from the install_lib command.</span>
        <span class="s1">log.info(</span><span class="s3">&quot;installing library code to %s&quot;</span><span class="s1">, self.bdist_dir)</span>
        <span class="s1">instcmd = self.get_finalized_command(</span><span class="s3">'install'</span><span class="s1">)</span>
        <span class="s1">old_root = instcmd.root</span>
        <span class="s1">instcmd.root = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.distribution.has_c_libraries() </span><span class="s2">and not </span><span class="s1">self.skip_build:</span>
            <span class="s1">self.run_command(</span><span class="s3">'build_clib'</span><span class="s1">)</span>
        <span class="s1">cmd = self.call_command(</span><span class="s3">'install_lib'</span><span class="s1">, warn_dir=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">instcmd.root = old_root</span>

        <span class="s1">all_outputs, ext_outputs = self.get_ext_outputs()</span>
        <span class="s1">self.stubs = []</span>
        <span class="s1">to_compile = []</span>
        <span class="s2">for </span><span class="s1">(p, ext_name) </span><span class="s2">in </span><span class="s1">enumerate(ext_outputs):</span>
            <span class="s1">filename, ext = os.path.splitext(ext_name)</span>
            <span class="s1">pyfile = os.path.join(self.bdist_dir, strip_module(filename) +</span>
                                  <span class="s3">'.py'</span><span class="s1">)</span>
            <span class="s1">self.stubs.append(pyfile)</span>
            <span class="s1">log.info(</span><span class="s3">&quot;creating stub loader for %s&quot;</span><span class="s1">, ext_name)</span>
            <span class="s2">if not </span><span class="s1">self.dry_run:</span>
                <span class="s1">write_stub(os.path.basename(ext_name), pyfile)</span>
            <span class="s1">to_compile.append(pyfile)</span>
            <span class="s1">ext_outputs[p] = ext_name.replace(os.sep, </span><span class="s3">'/'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">to_compile:</span>
            <span class="s1">cmd.byte_compile(to_compile)</span>
        <span class="s2">if </span><span class="s1">self.distribution.data_files:</span>
            <span class="s1">self.do_install_data()</span>

        <span class="s0"># Make the EGG-INFO directory</span>
        <span class="s1">archive_root = self.bdist_dir</span>
        <span class="s1">egg_info = os.path.join(archive_root, </span><span class="s3">'EGG-INFO'</span><span class="s1">)</span>
        <span class="s1">self.mkpath(egg_info)</span>
        <span class="s2">if </span><span class="s1">self.distribution.scripts:</span>
            <span class="s1">script_dir = os.path.join(egg_info, </span><span class="s3">'scripts'</span><span class="s1">)</span>
            <span class="s1">log.info(</span><span class="s3">&quot;installing scripts to %s&quot;</span><span class="s1">, script_dir)</span>
            <span class="s1">self.call_command(</span><span class="s3">'install_scripts'</span><span class="s1">, install_dir=script_dir,</span>
                              <span class="s1">no_ep=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">self.copy_metadata_to(egg_info)</span>
        <span class="s1">native_libs = os.path.join(egg_info, </span><span class="s3">&quot;native_libs.txt&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">all_outputs:</span>
            <span class="s1">log.info(</span><span class="s3">&quot;writing %s&quot;</span><span class="s1">, native_libs)</span>
            <span class="s2">if not </span><span class="s1">self.dry_run:</span>
                <span class="s1">ensure_directory(native_libs)</span>
                <span class="s1">libs_file = open(native_libs, </span><span class="s3">'wt'</span><span class="s1">)</span>
                <span class="s1">libs_file.write(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">.join(all_outputs))</span>
                <span class="s1">libs_file.write(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">)</span>
                <span class="s1">libs_file.close()</span>
        <span class="s2">elif </span><span class="s1">os.path.isfile(native_libs):</span>
            <span class="s1">log.info(</span><span class="s3">&quot;removing %s&quot;</span><span class="s1">, native_libs)</span>
            <span class="s2">if not </span><span class="s1">self.dry_run:</span>
                <span class="s1">os.unlink(native_libs)</span>

        <span class="s1">write_safety_flag(</span>
            <span class="s1">os.path.join(archive_root, </span><span class="s3">'EGG-INFO'</span><span class="s1">), self.zip_safe()</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">os.path.exists(os.path.join(self.egg_info, </span><span class="s3">'depends.txt'</span><span class="s1">)):</span>
            <span class="s1">log.warn(</span>
                <span class="s3">&quot;WARNING: 'depends.txt' will not be used by setuptools 0.6!</span><span class="s5">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;Use the install_requires/extras_require setup() args instead.&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.exclude_source_files:</span>
            <span class="s1">self.zap_pyfiles()</span>

        <span class="s0"># Make the archive</span>
        <span class="s1">make_zipfile(self.egg_output, archive_root, verbose=self.verbose,</span>
                     <span class="s1">dry_run=self.dry_run, mode=self.gen_header())</span>
        <span class="s2">if not </span><span class="s1">self.keep_temp:</span>
            <span class="s1">remove_tree(self.bdist_dir, dry_run=self.dry_run)</span>

        <span class="s0"># Add to 'Distribution.dist_files' so that the &quot;upload&quot; command works</span>
        <span class="s1">getattr(self.distribution, </span><span class="s3">'dist_files'</span><span class="s1">, []).append(</span>
            <span class="s1">(</span><span class="s3">'bdist_egg'</span><span class="s1">, get_python_version(), self.egg_output))</span>

    <span class="s2">def </span><span class="s1">zap_pyfiles(self):</span>
        <span class="s1">log.info(</span><span class="s3">&quot;Removing .py files from temporary directory&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">base, dirs, files </span><span class="s2">in </span><span class="s1">walk_egg(self.bdist_dir):</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">files:</span>
                <span class="s1">path = os.path.join(base, name)</span>

                <span class="s2">if </span><span class="s1">name.endswith(</span><span class="s3">'.py'</span><span class="s1">):</span>
                    <span class="s1">log.debug(</span><span class="s3">&quot;Deleting %s&quot;</span><span class="s1">, path)</span>
                    <span class="s1">os.unlink(path)</span>

                <span class="s2">if </span><span class="s1">base.endswith(</span><span class="s3">'__pycache__'</span><span class="s1">):</span>
                    <span class="s1">path_old = path</span>

                    <span class="s1">pattern = </span><span class="s3">r'(?P&lt;name&gt;.+)\.(?P&lt;magic&gt;[^.]+)\.pyc'</span>
                    <span class="s1">m = re.match(pattern, name)</span>
                    <span class="s1">path_new = os.path.join(</span>
                        <span class="s1">base, os.pardir, m.group(</span><span class="s3">'name'</span><span class="s1">) + </span><span class="s3">'.pyc'</span><span class="s1">)</span>
                    <span class="s1">log.info(</span>
                        <span class="s3">&quot;Renaming file from [%s] to [%s]&quot;</span>
                        <span class="s1">% (path_old, path_new))</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">os.remove(path_new)</span>
                    <span class="s2">except </span><span class="s1">OSError:</span>
                        <span class="s2">pass</span>
                    <span class="s1">os.rename(path_old, path_new)</span>

    <span class="s2">def </span><span class="s1">zip_safe(self):</span>
        <span class="s1">safe = getattr(self.distribution, </span><span class="s3">'zip_safe'</span><span class="s1">, </span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">safe </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">safe</span>
        <span class="s1">log.warn(</span><span class="s3">&quot;zip_safe flag not set; analyzing archive contents...&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">analyze_egg(self.bdist_dir, self.stubs)</span>

    <span class="s2">def </span><span class="s1">gen_header(self):</span>
        <span class="s1">epm = EntryPoint.parse_map(self.distribution.entry_points </span><span class="s2">or </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">ep = epm.get(</span><span class="s3">'setuptools.installation'</span><span class="s1">, {}).get(</span><span class="s3">'eggsecutable'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">ep </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">'w'  </span><span class="s0"># not an eggsecutable, do it the usual way.</span>

        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;Eggsecutables are deprecated and will be removed in a future &quot;</span>
            <span class="s3">&quot;version.&quot;</span><span class="s1">,</span>
            <span class="s1">SetuptoolsDeprecationWarning</span>
        <span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">ep.attrs </span><span class="s2">or </span><span class="s1">ep.extras:</span>
            <span class="s2">raise </span><span class="s1">DistutilsSetupError(</span>
                <span class="s3">&quot;eggsecutable entry point (%r) cannot have 'extras' &quot;</span>
                <span class="s3">&quot;or refer to a module&quot; </span><span class="s1">% (ep,)</span>
            <span class="s1">)</span>

        <span class="s1">pyver = </span><span class="s3">'{}.{}'</span><span class="s1">.format(*sys.version_info)</span>
        <span class="s1">pkg = ep.module_name</span>
        <span class="s1">full = </span><span class="s3">'.'</span><span class="s1">.join(ep.attrs)</span>
        <span class="s1">base = ep.attrs[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">basename = os.path.basename(self.egg_output)</span>

        <span class="s1">header = (</span>
            <span class="s3">&quot;#!/bin/sh</span><span class="s5">\n</span><span class="s3">&quot;</span>
            <span class="s3">'if [ `basename $0` = &quot;%(basename)s&quot; ]</span><span class="s5">\n</span><span class="s3">'</span>
            <span class="s3">'then exec python%(pyver)s -c &quot;'</span>
            <span class="s3">&quot;import sys, os; sys.path.insert(0, os.path.abspath('$0')); &quot;</span>
            <span class="s3">&quot;from %(pkg)s import %(base)s; sys.exit(%(full)s())&quot;</span>
            <span class="s3">'&quot; &quot;$@&quot;</span><span class="s5">\n</span><span class="s3">'</span>
            <span class="s3">'else</span><span class="s5">\n</span><span class="s3">'</span>
            <span class="s3">'  echo $0 is not the correct name for this egg file.</span><span class="s5">\n</span><span class="s3">'</span>
            <span class="s3">'  echo Please rename it back to %(basename)s and try again.</span><span class="s5">\n</span><span class="s3">'</span>
            <span class="s3">'  exec false</span><span class="s5">\n</span><span class="s3">'</span>
            <span class="s3">'fi</span><span class="s5">\n</span><span class="s3">'</span>
        <span class="s1">) % locals()</span>

        <span class="s2">if not </span><span class="s1">self.dry_run:</span>
            <span class="s1">mkpath(os.path.dirname(self.egg_output), dry_run=self.dry_run)</span>
            <span class="s1">f = open(self.egg_output, </span><span class="s3">'w'</span><span class="s1">)</span>
            <span class="s1">f.write(header)</span>
            <span class="s1">f.close()</span>
        <span class="s2">return </span><span class="s3">'a'</span>

    <span class="s2">def </span><span class="s1">copy_metadata_to(self, target_dir):</span>
        <span class="s0">&quot;Copy metadata (egg info) to the target_dir&quot;</span>
        <span class="s0"># normalize the path (so that a forward-slash in egg_info will</span>
        <span class="s0"># match using startswith below)</span>
        <span class="s1">norm_egg_info = os.path.normpath(self.egg_info)</span>
        <span class="s1">prefix = os.path.join(norm_egg_info, </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">self.ei_cmd.filelist.files:</span>
            <span class="s2">if </span><span class="s1">path.startswith(prefix):</span>
                <span class="s1">target = os.path.join(target_dir, path[len(prefix):])</span>
                <span class="s1">ensure_directory(target)</span>
                <span class="s1">self.copy_file(path, target)</span>

    <span class="s2">def </span><span class="s1">get_ext_outputs(self):</span>
        <span class="s0">&quot;&quot;&quot;Get a list of relative paths to C extensions in the output distro&quot;&quot;&quot;</span>

        <span class="s1">all_outputs = []</span>
        <span class="s1">ext_outputs = []</span>

        <span class="s1">paths = {self.bdist_dir: </span><span class="s3">''</span><span class="s1">}</span>
        <span class="s2">for </span><span class="s1">base, dirs, files </span><span class="s2">in </span><span class="s1">sorted_walk(self.bdist_dir):</span>
            <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">files:</span>
                <span class="s2">if </span><span class="s1">os.path.splitext(filename)[</span><span class="s4">1</span><span class="s1">].lower() </span><span class="s2">in </span><span class="s1">NATIVE_EXTENSIONS:</span>
                    <span class="s1">all_outputs.append(paths[base] + filename)</span>
            <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">dirs:</span>
                <span class="s1">paths[os.path.join(base, filename)] = (paths[base] +</span>
                                                       <span class="s1">filename + </span><span class="s3">'/'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.distribution.has_ext_modules():</span>
            <span class="s1">build_cmd = self.get_finalized_command(</span><span class="s3">'build_ext'</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">build_cmd.extensions:</span>
                <span class="s2">if </span><span class="s1">isinstance(ext, Library):</span>
                    <span class="s2">continue</span>
                <span class="s1">fullname = build_cmd.get_ext_fullname(ext.name)</span>
                <span class="s1">filename = build_cmd.get_ext_filename(fullname)</span>
                <span class="s2">if not </span><span class="s1">os.path.basename(filename).startswith(</span><span class="s3">'dl-'</span><span class="s1">):</span>
                    <span class="s2">if </span><span class="s1">os.path.exists(os.path.join(self.bdist_dir, filename)):</span>
                        <span class="s1">ext_outputs.append(filename)</span>

        <span class="s2">return </span><span class="s1">all_outputs, ext_outputs</span>


<span class="s1">NATIVE_EXTENSIONS = dict.fromkeys(</span><span class="s3">'.dll .so .dylib .pyd'</span><span class="s1">.split())</span>


<span class="s2">def </span><span class="s1">walk_egg(egg_dir):</span>
    <span class="s0">&quot;&quot;&quot;Walk an unpacked egg's contents, skipping the metadata directory&quot;&quot;&quot;</span>
    <span class="s1">walker = sorted_walk(egg_dir)</span>
    <span class="s1">base, dirs, files = next(walker)</span>
    <span class="s2">if </span><span class="s3">'EGG-INFO' </span><span class="s2">in </span><span class="s1">dirs:</span>
        <span class="s1">dirs.remove(</span><span class="s3">'EGG-INFO'</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">base, dirs, files</span>
    <span class="s2">for </span><span class="s1">bdf </span><span class="s2">in </span><span class="s1">walker:</span>
        <span class="s2">yield </span><span class="s1">bdf</span>


<span class="s2">def </span><span class="s1">analyze_egg(egg_dir, stubs):</span>
    <span class="s0"># check for existing flag in EGG-INFO</span>
    <span class="s2">for </span><span class="s1">flag, fn </span><span class="s2">in </span><span class="s1">safety_flags.items():</span>
        <span class="s2">if </span><span class="s1">os.path.exists(os.path.join(egg_dir, </span><span class="s3">'EGG-INFO'</span><span class="s1">, fn)):</span>
            <span class="s2">return </span><span class="s1">flag</span>
    <span class="s2">if not </span><span class="s1">can_scan():</span>
        <span class="s2">return False</span>
    <span class="s1">safe = </span><span class="s2">True</span>
    <span class="s2">for </span><span class="s1">base, dirs, files </span><span class="s2">in </span><span class="s1">walk_egg(egg_dir):</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">files:</span>
            <span class="s2">if </span><span class="s1">name.endswith(</span><span class="s3">'.py'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">name.endswith(</span><span class="s3">'.pyw'</span><span class="s1">):</span>
                <span class="s2">continue</span>
            <span class="s2">elif </span><span class="s1">name.endswith(</span><span class="s3">'.pyc'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">name.endswith(</span><span class="s3">'.pyo'</span><span class="s1">):</span>
                <span class="s0"># always scan, even if we already know we're not safe</span>
                <span class="s1">safe = scan_module(egg_dir, base, name, stubs) </span><span class="s2">and </span><span class="s1">safe</span>
    <span class="s2">return </span><span class="s1">safe</span>


<span class="s2">def </span><span class="s1">write_safety_flag(egg_dir, safe):</span>
    <span class="s0"># Write or remove zip safety flag file(s)</span>
    <span class="s2">for </span><span class="s1">flag, fn </span><span class="s2">in </span><span class="s1">safety_flags.items():</span>
        <span class="s1">fn = os.path.join(egg_dir, fn)</span>
        <span class="s2">if </span><span class="s1">os.path.exists(fn):</span>
            <span class="s2">if </span><span class="s1">safe </span><span class="s2">is None or </span><span class="s1">bool(safe) != flag:</span>
                <span class="s1">os.unlink(fn)</span>
        <span class="s2">elif </span><span class="s1">safe </span><span class="s2">is not None and </span><span class="s1">bool(safe) == flag:</span>
            <span class="s1">f = open(fn, </span><span class="s3">'wt'</span><span class="s1">)</span>
            <span class="s1">f.write(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">)</span>
            <span class="s1">f.close()</span>


<span class="s1">safety_flags = {</span>
    <span class="s2">True</span><span class="s1">: </span><span class="s3">'zip-safe'</span><span class="s1">,</span>
    <span class="s2">False</span><span class="s1">: </span><span class="s3">'not-zip-safe'</span><span class="s1">,</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">scan_module(egg_dir, base, name, stubs):</span>
    <span class="s0">&quot;&quot;&quot;Check whether module possibly uses unsafe-for-zipfile stuff&quot;&quot;&quot;</span>

    <span class="s1">filename = os.path.join(base, name)</span>
    <span class="s2">if </span><span class="s1">filename[:-</span><span class="s4">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">stubs:</span>
        <span class="s2">return True  </span><span class="s0"># Extension module</span>
    <span class="s1">pkg = base[len(egg_dir) + </span><span class="s4">1</span><span class="s1">:].replace(os.sep, </span><span class="s3">'.'</span><span class="s1">)</span>
    <span class="s1">module = pkg + (pkg </span><span class="s2">and </span><span class="s3">'.' </span><span class="s2">or </span><span class="s3">''</span><span class="s1">) + os.path.splitext(name)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">six.PY2:</span>
        <span class="s1">skip = </span><span class="s4">8  </span><span class="s0"># skip magic &amp; date</span>
    <span class="s2">elif </span><span class="s1">sys.version_info &lt; (</span><span class="s4">3</span><span class="s1">, </span><span class="s4">7</span><span class="s1">):</span>
        <span class="s1">skip = </span><span class="s4">12  </span><span class="s0"># skip magic &amp; date &amp; file size</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">skip = </span><span class="s4">16  </span><span class="s0"># skip magic &amp; reserved? &amp; date &amp; file size</span>
    <span class="s1">f = open(filename, </span><span class="s3">'rb'</span><span class="s1">)</span>
    <span class="s1">f.read(skip)</span>
    <span class="s1">code = marshal.load(f)</span>
    <span class="s1">f.close()</span>
    <span class="s1">safe = </span><span class="s2">True</span>
    <span class="s1">symbols = dict.fromkeys(iter_symbols(code))</span>
    <span class="s2">for </span><span class="s1">bad </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'__file__'</span><span class="s1">, </span><span class="s3">'__path__'</span><span class="s1">]:</span>
        <span class="s2">if </span><span class="s1">bad </span><span class="s2">in </span><span class="s1">symbols:</span>
            <span class="s1">log.warn(</span><span class="s3">&quot;%s: module references %s&quot;</span><span class="s1">, module, bad)</span>
            <span class="s1">safe = </span><span class="s2">False</span>
    <span class="s2">if </span><span class="s3">'inspect' </span><span class="s2">in </span><span class="s1">symbols:</span>
        <span class="s2">for </span><span class="s1">bad </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'getsource'</span><span class="s1">, </span><span class="s3">'getabsfile'</span><span class="s1">, </span><span class="s3">'getsourcefile'</span><span class="s1">, </span><span class="s3">'getfile'</span>
            <span class="s3">'getsourcelines'</span><span class="s1">, </span><span class="s3">'findsource'</span><span class="s1">, </span><span class="s3">'getcomments'</span><span class="s1">, </span><span class="s3">'getframeinfo'</span><span class="s1">,</span>
            <span class="s3">'getinnerframes'</span><span class="s1">, </span><span class="s3">'getouterframes'</span><span class="s1">, </span><span class="s3">'stack'</span><span class="s1">, </span><span class="s3">'trace'</span>
        <span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">bad </span><span class="s2">in </span><span class="s1">symbols:</span>
                <span class="s1">log.warn(</span><span class="s3">&quot;%s: module MAY be using inspect.%s&quot;</span><span class="s1">, module, bad)</span>
                <span class="s1">safe = </span><span class="s2">False</span>
    <span class="s2">return </span><span class="s1">safe</span>


<span class="s2">def </span><span class="s1">iter_symbols(code):</span>
    <span class="s0">&quot;&quot;&quot;Yield names and strings used by `code` and its nested code objects&quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">code.co_names:</span>
        <span class="s2">yield </span><span class="s1">name</span>
    <span class="s2">for </span><span class="s1">const </span><span class="s2">in </span><span class="s1">code.co_consts:</span>
        <span class="s2">if </span><span class="s1">isinstance(const, six.string_types):</span>
            <span class="s2">yield </span><span class="s1">const</span>
        <span class="s2">elif </span><span class="s1">isinstance(const, CodeType):</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">iter_symbols(const):</span>
                <span class="s2">yield </span><span class="s1">name</span>


<span class="s2">def </span><span class="s1">can_scan():</span>
    <span class="s2">if not </span><span class="s1">sys.platform.startswith(</span><span class="s3">'java'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">sys.platform != </span><span class="s3">'cli'</span><span class="s1">:</span>
        <span class="s0"># CPython, PyPy, etc.</span>
        <span class="s2">return True</span>
    <span class="s1">log.warn(</span><span class="s3">&quot;Unable to analyze compiled code on this platform.&quot;</span><span class="s1">)</span>
    <span class="s1">log.warn(</span><span class="s3">&quot;Please ask the author to include a 'zip_safe'&quot;</span>
             <span class="s3">&quot; setting (either True or False) in the package's setup.py&quot;</span><span class="s1">)</span>


<span class="s0"># Attribute names of options for commands that might need to be convinced to</span>
<span class="s0"># install to the egg build directory</span>

<span class="s1">INSTALL_DIRECTORY_ATTRS = [</span>
    <span class="s3">'install_lib'</span><span class="s1">, </span><span class="s3">'install_dir'</span><span class="s1">, </span><span class="s3">'install_data'</span><span class="s1">, </span><span class="s3">'install_base'</span>
<span class="s1">]</span>


<span class="s2">def </span><span class="s1">make_zipfile(zip_filename, base_dir, verbose=</span><span class="s4">0</span><span class="s1">, dry_run=</span><span class="s4">0</span><span class="s1">, compress=</span><span class="s2">True</span><span class="s1">,</span>
                 <span class="s1">mode=</span><span class="s3">'w'</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Create a zip file from all the files under 'base_dir'.  The output 
    zip file will be named 'base_dir' + &quot;.zip&quot;.  Uses either the &quot;zipfile&quot; 
    Python module (if available) or the InfoZIP &quot;zip&quot; utility (if installed 
    and found on the default search path).  If neither tool is available, 
    raises DistutilsExecError.  Returns the name of the output zip file. 
    &quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">zipfile</span>

    <span class="s1">mkpath(os.path.dirname(zip_filename), dry_run=dry_run)</span>
    <span class="s1">log.info(</span><span class="s3">&quot;creating '%s' and adding '%s' to it&quot;</span><span class="s1">, zip_filename, base_dir)</span>

    <span class="s2">def </span><span class="s1">visit(z, dirname, names):</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
            <span class="s1">path = os.path.normpath(os.path.join(dirname, name))</span>
            <span class="s2">if </span><span class="s1">os.path.isfile(path):</span>
                <span class="s1">p = path[len(base_dir) + </span><span class="s4">1</span><span class="s1">:]</span>
                <span class="s2">if not </span><span class="s1">dry_run:</span>
                    <span class="s1">z.write(path, p)</span>
                <span class="s1">log.debug(</span><span class="s3">&quot;adding '%s'&quot;</span><span class="s1">, p)</span>

    <span class="s1">compression = zipfile.ZIP_DEFLATED </span><span class="s2">if </span><span class="s1">compress </span><span class="s2">else </span><span class="s1">zipfile.ZIP_STORED</span>
    <span class="s2">if not </span><span class="s1">dry_run:</span>
        <span class="s1">z = zipfile.ZipFile(zip_filename, mode, compression=compression)</span>
        <span class="s2">for </span><span class="s1">dirname, dirs, files </span><span class="s2">in </span><span class="s1">sorted_walk(base_dir):</span>
            <span class="s1">visit(z, dirname, files)</span>
        <span class="s1">z.close()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">dirname, dirs, files </span><span class="s2">in </span><span class="s1">sorted_walk(base_dir):</span>
            <span class="s1">visit(</span><span class="s2">None</span><span class="s1">, dirname, files)</span>
    <span class="s2">return </span><span class="s1">zip_filename</span>
</pre>
</body>
</html>