<html>
<head>
<title>candidates.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
candidates.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">logging</span>
<span class="s0">import </span><span class="s1">sys</span>

<span class="s0">from </span><span class="s1">pip._vendor.packaging.specifiers </span><span class="s0">import </span><span class="s1">InvalidSpecifier, SpecifierSet</span>
<span class="s0">from </span><span class="s1">pip._vendor.packaging.utils </span><span class="s0">import </span><span class="s1">canonicalize_name</span>
<span class="s0">from </span><span class="s1">pip._vendor.packaging.version </span><span class="s0">import </span><span class="s1">Version</span>

<span class="s0">from </span><span class="s1">pip._internal.exceptions </span><span class="s0">import </span><span class="s1">HashError, MetadataInconsistent</span>
<span class="s0">from </span><span class="s1">pip._internal.models.wheel </span><span class="s0">import </span><span class="s1">Wheel</span>
<span class="s0">from </span><span class="s1">pip._internal.req.constructors </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">install_req_from_editable,</span>
    <span class="s1">install_req_from_line,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pip._internal.req.req_install </span><span class="s0">import </span><span class="s1">InstallRequirement</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.misc </span><span class="s0">import </span><span class="s1">dist_is_editable, normalize_version_info</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.packaging </span><span class="s0">import </span><span class="s1">get_requires_python</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.typing </span><span class="s0">import </span><span class="s1">MYPY_CHECK_RUNNING</span>

<span class="s0">from </span><span class="s1">.base </span><span class="s0">import </span><span class="s1">Candidate, format_name</span>

<span class="s0">if </span><span class="s1">MYPY_CHECK_RUNNING:</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any, FrozenSet, Iterable, Optional, Tuple, Union</span>

    <span class="s0">from </span><span class="s1">pip._vendor.packaging.version </span><span class="s0">import </span><span class="s1">_BaseVersion</span>
    <span class="s0">from </span><span class="s1">pip._vendor.pkg_resources </span><span class="s0">import </span><span class="s1">Distribution</span>

    <span class="s0">from </span><span class="s1">pip._internal.models.link </span><span class="s0">import </span><span class="s1">Link</span>

    <span class="s0">from </span><span class="s1">.base </span><span class="s0">import </span><span class="s1">Requirement</span>
    <span class="s0">from </span><span class="s1">.factory </span><span class="s0">import </span><span class="s1">Factory</span>

    <span class="s1">BaseCandidate = Union[</span>
        <span class="s2">&quot;AlreadyInstalledCandidate&quot;</span><span class="s1">,</span>
        <span class="s2">&quot;EditableCandidate&quot;</span><span class="s1">,</span>
        <span class="s2">&quot;LinkCandidate&quot;</span><span class="s1">,</span>
    <span class="s1">]</span>


<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s0">def </span><span class="s1">make_install_req_from_link(link, template):</span>
    <span class="s3"># type: (Link, InstallRequirement) -&gt; InstallRequirement</span>
    <span class="s0">assert not </span><span class="s1">template.editable, </span><span class="s2">&quot;template is editable&quot;</span>
    <span class="s0">if </span><span class="s1">template.req:</span>
        <span class="s1">line = str(template.req)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">line = link.url</span>
    <span class="s1">ireq = install_req_from_line(</span>
        <span class="s1">line,</span>
        <span class="s1">user_supplied=template.user_supplied,</span>
        <span class="s1">comes_from=template.comes_from,</span>
        <span class="s1">use_pep517=template.use_pep517,</span>
        <span class="s1">isolated=template.isolated,</span>
        <span class="s1">constraint=template.constraint,</span>
        <span class="s1">options=dict(</span>
            <span class="s1">install_options=template.install_options,</span>
            <span class="s1">global_options=template.global_options,</span>
            <span class="s1">hashes=template.hash_options</span>
        <span class="s1">),</span>
    <span class="s1">)</span>
    <span class="s1">ireq.original_link = template.original_link</span>
    <span class="s1">ireq.link = link</span>
    <span class="s0">return </span><span class="s1">ireq</span>


<span class="s0">def </span><span class="s1">make_install_req_from_editable(link, template):</span>
    <span class="s3"># type: (Link, InstallRequirement) -&gt; InstallRequirement</span>
    <span class="s0">assert </span><span class="s1">template.editable, </span><span class="s2">&quot;template not editable&quot;</span>
    <span class="s0">return </span><span class="s1">install_req_from_editable(</span>
        <span class="s1">link.url,</span>
        <span class="s1">user_supplied=template.user_supplied,</span>
        <span class="s1">comes_from=template.comes_from,</span>
        <span class="s1">use_pep517=template.use_pep517,</span>
        <span class="s1">isolated=template.isolated,</span>
        <span class="s1">constraint=template.constraint,</span>
        <span class="s1">options=dict(</span>
            <span class="s1">install_options=template.install_options,</span>
            <span class="s1">global_options=template.global_options,</span>
            <span class="s1">hashes=template.hash_options</span>
        <span class="s1">),</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">make_install_req_from_dist(dist, template):</span>
    <span class="s3"># type: (Distribution, InstallRequirement) -&gt; InstallRequirement</span>
    <span class="s1">project_name = canonicalize_name(dist.project_name)</span>
    <span class="s0">if </span><span class="s1">template.req:</span>
        <span class="s1">line = str(template.req)</span>
    <span class="s0">elif </span><span class="s1">template.link:</span>
        <span class="s1">line = </span><span class="s2">&quot;{} @ {}&quot;</span><span class="s1">.format(project_name, template.link.url)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">line = </span><span class="s2">&quot;{}=={}&quot;</span><span class="s1">.format(project_name, dist.parsed_version)</span>
    <span class="s1">ireq = install_req_from_line(</span>
        <span class="s1">line,</span>
        <span class="s1">user_supplied=template.user_supplied,</span>
        <span class="s1">comes_from=template.comes_from,</span>
        <span class="s1">use_pep517=template.use_pep517,</span>
        <span class="s1">isolated=template.isolated,</span>
        <span class="s1">constraint=template.constraint,</span>
        <span class="s1">options=dict(</span>
            <span class="s1">install_options=template.install_options,</span>
            <span class="s1">global_options=template.global_options,</span>
            <span class="s1">hashes=template.hash_options</span>
        <span class="s1">),</span>
    <span class="s1">)</span>
    <span class="s1">ireq.satisfied_by = dist</span>
    <span class="s0">return </span><span class="s1">ireq</span>


<span class="s0">class </span><span class="s1">_InstallRequirementBackedCandidate(Candidate):</span>
    <span class="s3">&quot;&quot;&quot;A candidate backed by an ``InstallRequirement``. 
 
    This represents a package request with the target not being already 
    in the environment, and needs to be fetched and installed. The backing 
    ``InstallRequirement`` is responsible for most of the leg work; this 
    class exposes appropriate information to the resolver. 
 
    :param link: The link passed to the ``InstallRequirement``. The backing 
        ``InstallRequirement`` will use this link to fetch the distribution. 
    :param source_link: The link this candidate &quot;originates&quot; from. This is 
        different from ``link`` when the link is found in the wheel cache. 
        ``link`` would point to the wheel cache, while this points to the 
        found remote link (e.g. from pypi.org). 
    &quot;&quot;&quot;</span>
    <span class="s1">is_installed = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">link,          </span><span class="s3"># type: Link</span>
        <span class="s1">source_link,   </span><span class="s3"># type: Link</span>
        <span class="s1">ireq,          </span><span class="s3"># type: InstallRequirement</span>
        <span class="s1">factory,       </span><span class="s3"># type: Factory</span>
        <span class="s1">name=</span><span class="s0">None</span><span class="s1">,     </span><span class="s3"># type: Optional[str]</span>
        <span class="s1">version=</span><span class="s0">None</span><span class="s1">,  </span><span class="s3"># type: Optional[_BaseVersion]</span>
    <span class="s1">):</span>
        <span class="s3"># type: (...) -&gt; None</span>
        <span class="s1">self._link = link</span>
        <span class="s1">self._source_link = source_link</span>
        <span class="s1">self._factory = factory</span>
        <span class="s1">self._ireq = ireq</span>
        <span class="s1">self._name = name</span>
        <span class="s1">self._version = version</span>
        <span class="s1">self._dist = </span><span class="s0">None  </span><span class="s3"># type: Optional[Distribution]</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s0">return </span><span class="s2">&quot;{} {}&quot;</span><span class="s1">.format(self.name, self.version)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s0">return </span><span class="s2">&quot;{class_name}({link!r})&quot;</span><span class="s1">.format(</span>
            <span class="s1">class_name=self.__class__.__name__,</span>
            <span class="s1">link=str(self._link),</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__hash__(self):</span>
        <span class="s3"># type: () -&gt; int</span>
        <span class="s0">return </span><span class="s1">hash((self.__class__, self._link))</span>

    <span class="s0">def </span><span class="s1">__eq__(self, other):</span>
        <span class="s3"># type: (Any) -&gt; bool</span>
        <span class="s0">if </span><span class="s1">isinstance(other, self.__class__):</span>
            <span class="s0">return </span><span class="s1">self._link == other._link</span>
        <span class="s0">return False</span>

    <span class="s3"># Needed for Python 2, which does not implement this by default</span>
    <span class="s0">def </span><span class="s1">__ne__(self, other):</span>
        <span class="s3"># type: (Any) -&gt; bool</span>
        <span class="s0">return not </span><span class="s1">self.__eq__(other)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">source_link(self):</span>
        <span class="s3"># type: () -&gt; Optional[Link]</span>
        <span class="s0">return </span><span class="s1">self._source_link</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">name(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s3">&quot;&quot;&quot;The normalised name of the project the candidate refers to&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._name = canonicalize_name(self.dist.project_name)</span>
        <span class="s0">return </span><span class="s1">self._name</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">version(self):</span>
        <span class="s3"># type: () -&gt; _BaseVersion</span>
        <span class="s0">if </span><span class="s1">self._version </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._version = self.dist.parsed_version</span>
        <span class="s0">return </span><span class="s1">self._version</span>

    <span class="s0">def </span><span class="s1">format_for_error(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s0">return </span><span class="s2">&quot;{} {} (from {})&quot;</span><span class="s1">.format(</span>
            <span class="s1">self.name,</span>
            <span class="s1">self.version,</span>
            <span class="s1">self._link.file_path </span><span class="s0">if </span><span class="s1">self._link.is_file </span><span class="s0">else </span><span class="s1">self._link</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_prepare_distribution(self):</span>
        <span class="s3"># type: () -&gt; Distribution</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;Override in subclass&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_check_metadata_consistency(self, dist):</span>
        <span class="s3"># type: (Distribution) -&gt; None</span>
        <span class="s3">&quot;&quot;&quot;Check for consistency of project name and version of dist.&quot;&quot;&quot;</span>
        <span class="s3"># TODO: (Longer term) Rather than abort, reject this candidate</span>
        <span class="s3">#       and backtrack. This would need resolvelib support.</span>
        <span class="s1">name = canonicalize_name(dist.project_name)</span>
        <span class="s0">if </span><span class="s1">self._name </span><span class="s0">is not None and </span><span class="s1">self._name != name:</span>
            <span class="s0">raise </span><span class="s1">MetadataInconsistent(self._ireq, </span><span class="s2">&quot;name&quot;</span><span class="s1">, dist.project_name)</span>
        <span class="s1">version = dist.parsed_version</span>
        <span class="s0">if </span><span class="s1">self._version </span><span class="s0">is not None and </span><span class="s1">self._version != version:</span>
            <span class="s0">raise </span><span class="s1">MetadataInconsistent(self._ireq, </span><span class="s2">&quot;version&quot;</span><span class="s1">, dist.version)</span>

    <span class="s0">def </span><span class="s1">_prepare(self):</span>
        <span class="s3"># type: () -&gt; None</span>
        <span class="s0">if </span><span class="s1">self._dist </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">dist = self._prepare_distribution()</span>
        <span class="s0">except </span><span class="s1">HashError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">e.req = self._ireq</span>
            <span class="s0">raise</span>

        <span class="s0">assert </span><span class="s1">dist </span><span class="s0">is not None</span><span class="s1">, </span><span class="s2">&quot;Distribution already installed&quot;</span>
        <span class="s1">self._check_metadata_consistency(dist)</span>
        <span class="s1">self._dist = dist</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">dist(self):</span>
        <span class="s3"># type: () -&gt; Distribution</span>
        <span class="s0">if </span><span class="s1">self._dist </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._prepare()</span>
        <span class="s0">return </span><span class="s1">self._dist</span>

    <span class="s0">def </span><span class="s1">_get_requires_python_dependency(self):</span>
        <span class="s3"># type: () -&gt; Optional[Requirement]</span>
        <span class="s1">requires_python = get_requires_python(self.dist)</span>
        <span class="s0">if </span><span class="s1">requires_python </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">spec = SpecifierSet(requires_python)</span>
        <span class="s0">except </span><span class="s1">InvalidSpecifier </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">message = </span><span class="s2">&quot;Package %r has an invalid Requires-Python: %s&quot;</span>
            <span class="s1">logger.warning(message, self.name, e)</span>
            <span class="s0">return None</span>
        <span class="s0">return </span><span class="s1">self._factory.make_requires_python_requirement(spec)</span>

    <span class="s0">def </span><span class="s1">iter_dependencies(self, with_requires):</span>
        <span class="s3"># type: (bool) -&gt; Iterable[Optional[Requirement]]</span>
        <span class="s1">requires = self.dist.requires() </span><span class="s0">if </span><span class="s1">with_requires </span><span class="s0">else </span><span class="s1">()</span>
        <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">requires:</span>
            <span class="s0">yield </span><span class="s1">self._factory.make_requirement_from_spec(str(r), self._ireq)</span>
        <span class="s0">yield </span><span class="s1">self._get_requires_python_dependency()</span>

    <span class="s0">def </span><span class="s1">get_install_requirement(self):</span>
        <span class="s3"># type: () -&gt; Optional[InstallRequirement]</span>
        <span class="s1">self._prepare()</span>
        <span class="s0">return </span><span class="s1">self._ireq</span>


<span class="s0">class </span><span class="s1">LinkCandidate(_InstallRequirementBackedCandidate):</span>
    <span class="s1">is_editable = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">link,          </span><span class="s3"># type: Link</span>
        <span class="s1">template,        </span><span class="s3"># type: InstallRequirement</span>
        <span class="s1">factory,       </span><span class="s3"># type: Factory</span>
        <span class="s1">name=</span><span class="s0">None</span><span class="s1">,     </span><span class="s3"># type: Optional[str]</span>
        <span class="s1">version=</span><span class="s0">None</span><span class="s1">,  </span><span class="s3"># type: Optional[_BaseVersion]</span>
    <span class="s1">):</span>
        <span class="s3"># type: (...) -&gt; None</span>
        <span class="s1">source_link = link</span>
        <span class="s1">cache_entry = factory.get_wheel_cache_entry(link, name)</span>
        <span class="s0">if </span><span class="s1">cache_entry </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">logger.debug(</span><span class="s2">&quot;Using cached wheel link: %s&quot;</span><span class="s1">, cache_entry.link)</span>
            <span class="s1">link = cache_entry.link</span>
        <span class="s1">ireq = make_install_req_from_link(link, template)</span>
        <span class="s0">assert </span><span class="s1">ireq.link == link</span>
        <span class="s0">if </span><span class="s1">ireq.link.is_wheel </span><span class="s0">and not </span><span class="s1">ireq.link.is_file:</span>
            <span class="s1">wheel = Wheel(ireq.link.filename)</span>
            <span class="s1">wheel_name = canonicalize_name(wheel.name)</span>
            <span class="s0">assert </span><span class="s1">name == wheel_name, (</span>
                <span class="s2">&quot;{!r} != {!r} for wheel&quot;</span><span class="s1">.format(name, wheel_name)</span>
            <span class="s1">)</span>
            <span class="s3"># Version may not be present for PEP 508 direct URLs</span>
            <span class="s0">if </span><span class="s1">version </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">wheel_version = Version(wheel.version)</span>
                <span class="s0">assert </span><span class="s1">version == wheel_version, (</span>
                    <span class="s2">&quot;{!r} != {!r} for wheel {}&quot;</span><span class="s1">.format(</span>
                        <span class="s1">version, wheel_version, name</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">(cache_entry </span><span class="s0">is not None and</span>
                <span class="s1">cache_entry.persistent </span><span class="s0">and</span>
                <span class="s1">template.link </span><span class="s0">is </span><span class="s1">template.original_link):</span>
            <span class="s1">ireq.original_link_is_in_wheel_cache = </span><span class="s0">True</span>

        <span class="s1">super(LinkCandidate, self).__init__(</span>
            <span class="s1">link=link,</span>
            <span class="s1">source_link=source_link,</span>
            <span class="s1">ireq=ireq,</span>
            <span class="s1">factory=factory,</span>
            <span class="s1">name=name,</span>
            <span class="s1">version=version,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_prepare_distribution(self):</span>
        <span class="s3"># type: () -&gt; Distribution</span>
        <span class="s0">return </span><span class="s1">self._factory.preparer.prepare_linked_requirement(</span>
            <span class="s1">self._ireq, parallel_builds=</span><span class="s0">True</span><span class="s1">,</span>
        <span class="s1">)</span>


<span class="s0">class </span><span class="s1">EditableCandidate(_InstallRequirementBackedCandidate):</span>
    <span class="s1">is_editable = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">link,          </span><span class="s3"># type: Link</span>
        <span class="s1">template,        </span><span class="s3"># type: InstallRequirement</span>
        <span class="s1">factory,       </span><span class="s3"># type: Factory</span>
        <span class="s1">name=</span><span class="s0">None</span><span class="s1">,     </span><span class="s3"># type: Optional[str]</span>
        <span class="s1">version=</span><span class="s0">None</span><span class="s1">,  </span><span class="s3"># type: Optional[_BaseVersion]</span>
    <span class="s1">):</span>
        <span class="s3"># type: (...) -&gt; None</span>
        <span class="s1">super(EditableCandidate, self).__init__(</span>
            <span class="s1">link=link,</span>
            <span class="s1">source_link=link,</span>
            <span class="s1">ireq=make_install_req_from_editable(link, template),</span>
            <span class="s1">factory=factory,</span>
            <span class="s1">name=name,</span>
            <span class="s1">version=version,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_prepare_distribution(self):</span>
        <span class="s3"># type: () -&gt; Distribution</span>
        <span class="s0">return </span><span class="s1">self._factory.preparer.prepare_editable_requirement(self._ireq)</span>


<span class="s0">class </span><span class="s1">AlreadyInstalledCandidate(Candidate):</span>
    <span class="s1">is_installed = </span><span class="s0">True</span>
    <span class="s1">source_link = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">dist,  </span><span class="s3"># type: Distribution</span>
        <span class="s1">template,  </span><span class="s3"># type: InstallRequirement</span>
        <span class="s1">factory,  </span><span class="s3"># type: Factory</span>
    <span class="s1">):</span>
        <span class="s3"># type: (...) -&gt; None</span>
        <span class="s1">self.dist = dist</span>
        <span class="s1">self._ireq = make_install_req_from_dist(dist, template)</span>
        <span class="s1">self._factory = factory</span>

        <span class="s3"># This is just logging some messages, so we can do it eagerly.</span>
        <span class="s3"># The returned dist would be exactly the same as self.dist because we</span>
        <span class="s3"># set satisfied_by in make_install_req_from_dist.</span>
        <span class="s3"># TODO: Supply reason based on force_reinstall and upgrade_strategy.</span>
        <span class="s1">skip_reason = </span><span class="s2">&quot;already satisfied&quot;</span>
        <span class="s1">factory.preparer.prepare_installed_requirement(self._ireq, skip_reason)</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s0">return </span><span class="s1">str(self.dist)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s0">return </span><span class="s2">&quot;{class_name}({distribution!r})&quot;</span><span class="s1">.format(</span>
            <span class="s1">class_name=self.__class__.__name__,</span>
            <span class="s1">distribution=self.dist,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__hash__(self):</span>
        <span class="s3"># type: () -&gt; int</span>
        <span class="s0">return </span><span class="s1">hash((self.__class__, self.name, self.version))</span>

    <span class="s0">def </span><span class="s1">__eq__(self, other):</span>
        <span class="s3"># type: (Any) -&gt; bool</span>
        <span class="s0">if </span><span class="s1">isinstance(other, self.__class__):</span>
            <span class="s0">return </span><span class="s1">self.name == other.name </span><span class="s0">and </span><span class="s1">self.version == other.version</span>
        <span class="s0">return False</span>

    <span class="s3"># Needed for Python 2, which does not implement this by default</span>
    <span class="s0">def </span><span class="s1">__ne__(self, other):</span>
        <span class="s3"># type: (Any) -&gt; bool</span>
        <span class="s0">return not </span><span class="s1">self.__eq__(other)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">name(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s0">return </span><span class="s1">canonicalize_name(self.dist.project_name)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">version(self):</span>
        <span class="s3"># type: () -&gt; _BaseVersion</span>
        <span class="s0">return </span><span class="s1">self.dist.parsed_version</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_editable(self):</span>
        <span class="s3"># type: () -&gt; bool</span>
        <span class="s0">return </span><span class="s1">dist_is_editable(self.dist)</span>

    <span class="s0">def </span><span class="s1">format_for_error(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s0">return </span><span class="s2">&quot;{} {} (Installed)&quot;</span><span class="s1">.format(self.name, self.version)</span>

    <span class="s0">def </span><span class="s1">iter_dependencies(self, with_requires):</span>
        <span class="s3"># type: (bool) -&gt; Iterable[Optional[Requirement]]</span>
        <span class="s0">if not </span><span class="s1">with_requires:</span>
            <span class="s0">return</span>
        <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">self.dist.requires():</span>
            <span class="s0">yield </span><span class="s1">self._factory.make_requirement_from_spec(str(r), self._ireq)</span>

    <span class="s0">def </span><span class="s1">get_install_requirement(self):</span>
        <span class="s3"># type: () -&gt; Optional[InstallRequirement]</span>
        <span class="s0">return None</span>


<span class="s0">class </span><span class="s1">ExtrasCandidate(Candidate):</span>
    <span class="s3">&quot;&quot;&quot;A candidate that has 'extras', indicating additional dependencies. 
 
    Requirements can be for a project with dependencies, something like 
    foo[extra].  The extras don't affect the project/version being installed 
    directly, but indicate that we need additional dependencies. We model that 
    by having an artificial ExtrasCandidate that wraps the &quot;base&quot; candidate. 
 
    The ExtrasCandidate differs from the base in the following ways: 
 
    1. It has a unique name, of the form foo[extra]. This causes the resolver 
       to treat it as a separate node in the dependency graph. 
    2. When we're getting the candidate's dependencies, 
       a) We specify that we want the extra dependencies as well. 
       b) We add a dependency on the base candidate. 
          See below for why this is needed. 
    3. We return None for the underlying InstallRequirement, as the base 
       candidate will provide it, and we don't want to end up with duplicates. 
 
    The dependency on the base candidate is needed so that the resolver can't 
    decide that it should recommend foo[extra1] version 1.0 and foo[extra2] 
    version 2.0. Having those candidates depend on foo=1.0 and foo=2.0 
    respectively forces the resolver to recognise that this is a conflict. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">base,  </span><span class="s3"># type: BaseCandidate</span>
        <span class="s1">extras,  </span><span class="s3"># type: FrozenSet[str]</span>
    <span class="s1">):</span>
        <span class="s3"># type: (...) -&gt; None</span>
        <span class="s1">self.base = base</span>
        <span class="s1">self.extras = extras</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s1">name, rest = str(self.base).split(</span><span class="s2">&quot; &quot;</span><span class="s1">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s2">&quot;{}[{}] {}&quot;</span><span class="s1">.format(name, </span><span class="s2">&quot;,&quot;</span><span class="s1">.join(self.extras), rest)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s0">return </span><span class="s2">&quot;{class_name}(base={base!r}, extras={extras!r})&quot;</span><span class="s1">.format(</span>
            <span class="s1">class_name=self.__class__.__name__,</span>
            <span class="s1">base=self.base,</span>
            <span class="s1">extras=self.extras,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__hash__(self):</span>
        <span class="s3"># type: () -&gt; int</span>
        <span class="s0">return </span><span class="s1">hash((self.base, self.extras))</span>

    <span class="s0">def </span><span class="s1">__eq__(self, other):</span>
        <span class="s3"># type: (Any) -&gt; bool</span>
        <span class="s0">if </span><span class="s1">isinstance(other, self.__class__):</span>
            <span class="s0">return </span><span class="s1">self.base == other.base </span><span class="s0">and </span><span class="s1">self.extras == other.extras</span>
        <span class="s0">return False</span>

    <span class="s3"># Needed for Python 2, which does not implement this by default</span>
    <span class="s0">def </span><span class="s1">__ne__(self, other):</span>
        <span class="s3"># type: (Any) -&gt; bool</span>
        <span class="s0">return not </span><span class="s1">self.__eq__(other)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">name(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s3">&quot;&quot;&quot;The normalised name of the project the candidate refers to&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">format_name(self.base.name, self.extras)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">version(self):</span>
        <span class="s3"># type: () -&gt; _BaseVersion</span>
        <span class="s0">return </span><span class="s1">self.base.version</span>

    <span class="s0">def </span><span class="s1">format_for_error(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s0">return </span><span class="s2">&quot;{} [{}]&quot;</span><span class="s1">.format(</span>
            <span class="s1">self.base.format_for_error(),</span>
            <span class="s2">&quot;, &quot;</span><span class="s1">.join(sorted(self.extras))</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_installed(self):</span>
        <span class="s3"># type: () -&gt; bool</span>
        <span class="s0">return </span><span class="s1">self.base.is_installed</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_editable(self):</span>
        <span class="s3"># type: () -&gt; bool</span>
        <span class="s0">return </span><span class="s1">self.base.is_editable</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">source_link(self):</span>
        <span class="s3"># type: () -&gt; Optional[Link]</span>
        <span class="s0">return </span><span class="s1">self.base.source_link</span>

    <span class="s0">def </span><span class="s1">iter_dependencies(self, with_requires):</span>
        <span class="s3"># type: (bool) -&gt; Iterable[Optional[Requirement]]</span>
        <span class="s1">factory = self.base._factory</span>

        <span class="s3"># Add a dependency on the exact base</span>
        <span class="s3"># (See note 2b in the class docstring)</span>
        <span class="s0">yield </span><span class="s1">factory.make_requirement_from_candidate(self.base)</span>
        <span class="s0">if not </span><span class="s1">with_requires:</span>
            <span class="s0">return</span>

        <span class="s3"># The user may have specified extras that the candidate doesn't</span>
        <span class="s3"># support. We ignore any unsupported extras here.</span>
        <span class="s1">valid_extras = self.extras.intersection(self.base.dist.extras)</span>
        <span class="s1">invalid_extras = self.extras.difference(self.base.dist.extras)</span>
        <span class="s0">for </span><span class="s1">extra </span><span class="s0">in </span><span class="s1">sorted(invalid_extras):</span>
            <span class="s1">logger.warning(</span>
                <span class="s2">&quot;%s %s does not provide the extra '%s'&quot;</span><span class="s1">,</span>
                <span class="s1">self.base.name,</span>
                <span class="s1">self.version,</span>
                <span class="s1">extra</span>
            <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">self.base.dist.requires(valid_extras):</span>
            <span class="s1">requirement = factory.make_requirement_from_spec(</span>
                <span class="s1">str(r), self.base._ireq, valid_extras,</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">requirement:</span>
                <span class="s0">yield </span><span class="s1">requirement</span>

    <span class="s0">def </span><span class="s1">get_install_requirement(self):</span>
        <span class="s3"># type: () -&gt; Optional[InstallRequirement]</span>
        <span class="s3"># We don't return anything here, because we always</span>
        <span class="s3"># depend on the base candidate, and we'll get the</span>
        <span class="s3"># install requirement from that.</span>
        <span class="s0">return None</span>


<span class="s0">class </span><span class="s1">RequiresPythonCandidate(Candidate):</span>
    <span class="s1">is_installed = </span><span class="s0">False</span>
    <span class="s1">source_link = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__init__(self, py_version_info):</span>
        <span class="s3"># type: (Optional[Tuple[int, ...]]) -&gt; None</span>
        <span class="s0">if </span><span class="s1">py_version_info </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">version_info = normalize_version_info(py_version_info)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">version_info = sys.version_info[:</span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">self._version = Version(</span><span class="s2">&quot;.&quot;</span><span class="s1">.join(str(c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">version_info))</span>

    <span class="s3"># We don't need to implement __eq__() and __ne__() since there is always</span>
    <span class="s3"># only one RequiresPythonCandidate in a resolution, i.e. the host Python.</span>
    <span class="s3"># The built-in object.__eq__() and object.__ne__() do exactly what we want.</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s0">return </span><span class="s2">&quot;Python {}&quot;</span><span class="s1">.format(self._version)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">name(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s3"># Avoid conflicting with the PyPI package &quot;Python&quot;.</span>
        <span class="s0">return </span><span class="s2">&quot;&lt;Python from Requires-Python&gt;&quot;</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">version(self):</span>
        <span class="s3"># type: () -&gt; _BaseVersion</span>
        <span class="s0">return </span><span class="s1">self._version</span>

    <span class="s0">def </span><span class="s1">format_for_error(self):</span>
        <span class="s3"># type: () -&gt; str</span>
        <span class="s0">return </span><span class="s2">&quot;Python {}&quot;</span><span class="s1">.format(self.version)</span>

    <span class="s0">def </span><span class="s1">iter_dependencies(self, with_requires):</span>
        <span class="s3"># type: (bool) -&gt; Iterable[Optional[Requirement]]</span>
        <span class="s0">return </span><span class="s1">()</span>

    <span class="s0">def </span><span class="s1">get_install_requirement(self):</span>
        <span class="s3"># type: () -&gt; Optional[InstallRequirement]</span>
        <span class="s0">return None</span>
</pre>
</body>
</html>