<html>
<head>
<title>_msvccompiler.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #067d17;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_msvccompiler.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;distutils._msvccompiler 
 
Contains MSVCCompiler, an implementation of the abstract CCompiler class 
for Microsoft Visual Studio 2015. 
 
The module is compatible with VS 2015 and later. You can find legacy support 
for older versions in distutils.msvc9compiler and distutils.msvccompiler. 
&quot;&quot;&quot;</span>

<span class="s0"># Written by Perry Stoll</span>
<span class="s0"># hacked by Robin Becker and Thomas Heller to do a better job of</span>
<span class="s0">#   finding DevStudio (through the registry)</span>
<span class="s0"># ported to VS 2005 and VS 2008 by Christian Heimes</span>
<span class="s0"># ported to VS 2015 by Steve Dower</span>

<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">subprocess</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">with </span><span class="s1">contextlib.suppress(ImportError):</span>
    <span class="s2">import </span><span class="s1">winreg</span>

<span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">DistutilsExecError, DistutilsPlatformError, \</span>
                             <span class="s1">CompileError, LibError, LinkError</span>
<span class="s2">from </span><span class="s1">distutils.ccompiler </span><span class="s2">import </span><span class="s1">CCompiler, gen_lib_options</span>
<span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">log</span>
<span class="s2">from </span><span class="s1">distutils.util </span><span class="s2">import </span><span class="s1">get_platform</span>

<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">count</span>

<span class="s2">def </span><span class="s1">_find_vc2015():</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">key = winreg.OpenKeyEx(</span>
            <span class="s1">winreg.HKEY_LOCAL_MACHINE,</span>
            <span class="s3">r&quot;Software\Microsoft\VisualStudio\SxS\VC7&quot;</span><span class="s1">,</span>
            <span class="s1">access=winreg.KEY_READ | winreg.KEY_WOW64_32KEY</span>
        <span class="s1">)</span>
    <span class="s2">except </span><span class="s1">OSError:</span>
        <span class="s1">log.debug(</span><span class="s3">&quot;Visual C++ is not registered&quot;</span><span class="s1">)</span>
        <span class="s2">return None</span><span class="s1">, </span><span class="s2">None</span>

    <span class="s1">best_version = </span><span class="s4">0</span>
    <span class="s1">best_dir = </span><span class="s2">None</span>
    <span class="s2">with </span><span class="s1">key:</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">count():</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">v, vc_dir, vt = winreg.EnumValue(key, i)</span>
            <span class="s2">except </span><span class="s1">OSError:</span>
                <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">v </span><span class="s2">and </span><span class="s1">vt == winreg.REG_SZ </span><span class="s2">and </span><span class="s1">os.path.isdir(vc_dir):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">version = int(float(v))</span>
                <span class="s2">except </span><span class="s1">(ValueError, TypeError):</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">version &gt;= </span><span class="s4">14 </span><span class="s2">and </span><span class="s1">version &gt; best_version:</span>
                    <span class="s1">best_version, best_dir = version, vc_dir</span>
    <span class="s2">return </span><span class="s1">best_version, best_dir</span>

<span class="s2">def </span><span class="s1">_find_vc2017():</span>
    <span class="s0">&quot;&quot;&quot;Returns &quot;15, path&quot; based on the result of invoking vswhere.exe 
    If no install is found, returns &quot;None, None&quot; 
 
    The version is returned to avoid unnecessarily changing the function 
    result. It may be ignored when the path is not None. 
 
    If vswhere.exe is not available, by definition, VS 2017 is not 
    installed. 
    &quot;&quot;&quot;</span>
    <span class="s1">root = os.environ.get(</span><span class="s3">&quot;ProgramFiles(x86)&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">os.environ.get(</span><span class="s3">&quot;ProgramFiles&quot;</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">root:</span>
        <span class="s2">return None</span><span class="s1">, </span><span class="s2">None</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">path = subprocess.check_output([</span>
            <span class="s1">os.path.join(root, </span><span class="s3">&quot;Microsoft Visual Studio&quot;</span><span class="s1">, </span><span class="s3">&quot;Installer&quot;</span><span class="s1">, </span><span class="s3">&quot;vswhere.exe&quot;</span><span class="s1">),</span>
            <span class="s3">&quot;-latest&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;-prerelease&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;-requires&quot;</span><span class="s1">, </span><span class="s3">&quot;Microsoft.VisualStudio.Component.VC.Tools.x86.x64&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;-property&quot;</span><span class="s1">, </span><span class="s3">&quot;installationPath&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;-products&quot;</span><span class="s1">, </span><span class="s3">&quot;*&quot;</span><span class="s1">,</span>
        <span class="s1">], encoding=</span><span class="s3">&quot;mbcs&quot;</span><span class="s1">, errors=</span><span class="s3">&quot;strict&quot;</span><span class="s1">).strip()</span>
    <span class="s2">except </span><span class="s1">(subprocess.CalledProcessError, OSError, UnicodeDecodeError):</span>
        <span class="s2">return None</span><span class="s1">, </span><span class="s2">None</span>

    <span class="s1">path = os.path.join(path, </span><span class="s3">&quot;VC&quot;</span><span class="s1">, </span><span class="s3">&quot;Auxiliary&quot;</span><span class="s1">, </span><span class="s3">&quot;Build&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">os.path.isdir(path):</span>
        <span class="s2">return </span><span class="s4">15</span><span class="s1">, path</span>

    <span class="s2">return None</span><span class="s1">, </span><span class="s2">None</span>

<span class="s1">PLAT_SPEC_TO_RUNTIME = {</span>
    <span class="s3">'x86' </span><span class="s1">: </span><span class="s3">'x86'</span><span class="s1">,</span>
    <span class="s3">'x86_amd64' </span><span class="s1">: </span><span class="s3">'x64'</span><span class="s1">,</span>
    <span class="s3">'x86_arm' </span><span class="s1">: </span><span class="s3">'arm'</span><span class="s1">,</span>
    <span class="s3">'x86_arm64' </span><span class="s1">: </span><span class="s3">'arm64'</span>
<span class="s1">}</span>

<span class="s2">def </span><span class="s1">_find_vcvarsall(plat_spec):</span>
    <span class="s0"># bpo-38597: Removed vcruntime return value</span>
    <span class="s1">_, best_dir = _find_vc2017()</span>

    <span class="s2">if not </span><span class="s1">best_dir:</span>
        <span class="s1">best_version, best_dir = _find_vc2015()</span>

    <span class="s2">if not </span><span class="s1">best_dir:</span>
        <span class="s1">log.debug(</span><span class="s3">&quot;No suitable Visual C++ version found&quot;</span><span class="s1">)</span>
        <span class="s2">return None</span><span class="s1">, </span><span class="s2">None</span>

    <span class="s1">vcvarsall = os.path.join(best_dir, </span><span class="s3">&quot;vcvarsall.bat&quot;</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">os.path.isfile(vcvarsall):</span>
        <span class="s1">log.debug(</span><span class="s3">&quot;%s cannot be found&quot;</span><span class="s1">, vcvarsall)</span>
        <span class="s2">return None</span><span class="s1">, </span><span class="s2">None</span>

    <span class="s2">return </span><span class="s1">vcvarsall, </span><span class="s2">None</span>

<span class="s2">def </span><span class="s1">_get_vc_env(plat_spec):</span>
    <span class="s2">if </span><span class="s1">os.getenv(</span><span class="s3">&quot;DISTUTILS_USE_SDK&quot;</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">key.lower(): value</span>
            <span class="s2">for </span><span class="s1">key, value </span><span class="s2">in </span><span class="s1">os.environ.items()</span>
        <span class="s1">}</span>

    <span class="s1">vcvarsall, _ = _find_vcvarsall(plat_spec)</span>
    <span class="s2">if not </span><span class="s1">vcvarsall:</span>
        <span class="s2">raise </span><span class="s1">DistutilsPlatformError(</span><span class="s3">&quot;Unable to find vcvarsall.bat&quot;</span><span class="s1">)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">out = subprocess.check_output(</span>
            <span class="s3">'cmd /u /c &quot;{}&quot; {} &amp;&amp; set'</span><span class="s1">.format(vcvarsall, plat_spec),</span>
            <span class="s1">stderr=subprocess.STDOUT,</span>
        <span class="s1">).decode(</span><span class="s3">'utf-16le'</span><span class="s1">, errors=</span><span class="s3">'replace'</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">subprocess.CalledProcessError </span><span class="s2">as </span><span class="s1">exc:</span>
        <span class="s1">log.error(exc.output)</span>
        <span class="s2">raise </span><span class="s1">DistutilsPlatformError(</span><span class="s3">&quot;Error executing {}&quot;</span>
                <span class="s1">.format(exc.cmd))</span>

    <span class="s1">env = {</span>
        <span class="s1">key.lower(): value</span>
        <span class="s2">for </span><span class="s1">key, _, value </span><span class="s2">in</span>
        <span class="s1">(line.partition(</span><span class="s3">'='</span><span class="s1">) </span><span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">out.splitlines())</span>
        <span class="s2">if </span><span class="s1">key </span><span class="s2">and </span><span class="s1">value</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">env</span>

<span class="s2">def </span><span class="s1">_find_exe(exe, paths=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Return path to an MSVC executable program. 
 
    Tries to find the program in several places: first, one of the 
    MSVC program search paths from the registry; next, the directories 
    in the PATH environment variable.  If any of those work, return an 
    absolute path that is known to exist.  If none of them work, just 
    return the original program name, 'exe'. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">paths:</span>
        <span class="s1">paths = os.getenv(</span><span class="s3">'path'</span><span class="s1">).split(os.pathsep)</span>
    <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">paths:</span>
        <span class="s1">fn = os.path.join(os.path.abspath(p), exe)</span>
        <span class="s2">if </span><span class="s1">os.path.isfile(fn):</span>
            <span class="s2">return </span><span class="s1">fn</span>
    <span class="s2">return </span><span class="s1">exe</span>

<span class="s0"># A map keyed by get_platform() return values to values accepted by</span>
<span class="s0"># 'vcvarsall.bat'. Always cross-compile from x86 to work with the</span>
<span class="s0"># lighter-weight MSVC installs that do not include native 64-bit tools.</span>
<span class="s1">PLAT_TO_VCVARS = {</span>
    <span class="s3">'win32' </span><span class="s1">: </span><span class="s3">'x86'</span><span class="s1">,</span>
    <span class="s3">'win-amd64' </span><span class="s1">: </span><span class="s3">'x86_amd64'</span><span class="s1">,</span>
    <span class="s3">'win-arm32' </span><span class="s1">: </span><span class="s3">'x86_arm'</span><span class="s1">,</span>
    <span class="s3">'win-arm64' </span><span class="s1">: </span><span class="s3">'x86_arm64'</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">MSVCCompiler(CCompiler) :</span>
    <span class="s0">&quot;&quot;&quot;Concrete class that implements an interface to Microsoft Visual C++, 
       as defined by the CCompiler abstract class.&quot;&quot;&quot;</span>

    <span class="s1">compiler_type = </span><span class="s3">'msvc'</span>

    <span class="s0"># Just set this so CCompiler's constructor doesn't barf.  We currently</span>
    <span class="s0"># don't use the 'set_executables()' bureaucracy provided by CCompiler,</span>
    <span class="s0"># as it really isn't necessary for this sort of single-compiler class.</span>
    <span class="s0"># Would be nice to have a consistent interface with UnixCCompiler,</span>
    <span class="s0"># though, so it's worth thinking about.</span>
    <span class="s1">executables = {}</span>

    <span class="s0"># Private class data (need to distinguish C from C++ source for compiler)</span>
    <span class="s1">_c_extensions = [</span><span class="s3">'.c'</span><span class="s1">]</span>
    <span class="s1">_cpp_extensions = [</span><span class="s3">'.cc'</span><span class="s1">, </span><span class="s3">'.cpp'</span><span class="s1">, </span><span class="s3">'.cxx'</span><span class="s1">]</span>
    <span class="s1">_rc_extensions = [</span><span class="s3">'.rc'</span><span class="s1">]</span>
    <span class="s1">_mc_extensions = [</span><span class="s3">'.mc'</span><span class="s1">]</span>

    <span class="s0"># Needed for the filename generation methods provided by the</span>
    <span class="s0"># base class, CCompiler.</span>
    <span class="s1">src_extensions = (_c_extensions + _cpp_extensions +</span>
                      <span class="s1">_rc_extensions + _mc_extensions)</span>
    <span class="s1">res_extension = </span><span class="s3">'.res'</span>
    <span class="s1">obj_extension = </span><span class="s3">'.obj'</span>
    <span class="s1">static_lib_extension = </span><span class="s3">'.lib'</span>
    <span class="s1">shared_lib_extension = </span><span class="s3">'.dll'</span>
    <span class="s1">static_lib_format = shared_lib_format = </span><span class="s3">'%s%s'</span>
    <span class="s1">exe_extension = </span><span class="s3">'.exe'</span>


    <span class="s2">def </span><span class="s1">__init__(self, verbose=</span><span class="s4">0</span><span class="s1">, dry_run=</span><span class="s4">0</span><span class="s1">, force=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">CCompiler.__init__ (self, verbose, dry_run, force)</span>
        <span class="s0"># target platform (.plat_name is consistent with 'bdist')</span>
        <span class="s1">self.plat_name = </span><span class="s2">None</span>
        <span class="s1">self.initialized = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">initialize(self, plat_name=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># multi-init means we would need to check platform same each time...</span>
        <span class="s2">assert not </span><span class="s1">self.initialized, </span><span class="s3">&quot;don't init multiple times&quot;</span>
        <span class="s2">if </span><span class="s1">plat_name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">plat_name = get_platform()</span>
        <span class="s0"># sanity check for platforms to prevent obscure errors later.</span>
        <span class="s2">if </span><span class="s1">plat_name </span><span class="s2">not in </span><span class="s1">PLAT_TO_VCVARS:</span>
            <span class="s2">raise </span><span class="s1">DistutilsPlatformError(</span><span class="s3">&quot;--plat-name must be one of {}&quot;</span>
                                         <span class="s1">.format(tuple(PLAT_TO_VCVARS)))</span>

        <span class="s0"># Get the vcvarsall.bat spec for the requested platform.</span>
        <span class="s1">plat_spec = PLAT_TO_VCVARS[plat_name]</span>

        <span class="s1">vc_env = _get_vc_env(plat_spec)</span>
        <span class="s2">if not </span><span class="s1">vc_env:</span>
            <span class="s2">raise </span><span class="s1">DistutilsPlatformError(</span><span class="s3">&quot;Unable to find a compatible &quot;</span>
                <span class="s3">&quot;Visual Studio installation.&quot;</span><span class="s1">)</span>

        <span class="s1">self._paths = vc_env.get(</span><span class="s3">'path'</span><span class="s1">, </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">paths = self._paths.split(os.pathsep)</span>
        <span class="s1">self.cc = _find_exe(</span><span class="s3">&quot;cl.exe&quot;</span><span class="s1">, paths)</span>
        <span class="s1">self.linker = _find_exe(</span><span class="s3">&quot;link.exe&quot;</span><span class="s1">, paths)</span>
        <span class="s1">self.lib = _find_exe(</span><span class="s3">&quot;lib.exe&quot;</span><span class="s1">, paths)</span>
        <span class="s1">self.rc = _find_exe(</span><span class="s3">&quot;rc.exe&quot;</span><span class="s1">, paths)   </span><span class="s0"># resource compiler</span>
        <span class="s1">self.mc = _find_exe(</span><span class="s3">&quot;mc.exe&quot;</span><span class="s1">, paths)   </span><span class="s0"># message compiler</span>
        <span class="s1">self.mt = _find_exe(</span><span class="s3">&quot;mt.exe&quot;</span><span class="s1">, paths)   </span><span class="s0"># message compiler</span>

        <span class="s2">for </span><span class="s1">dir </span><span class="s2">in </span><span class="s1">vc_env.get(</span><span class="s3">'include'</span><span class="s1">, </span><span class="s3">''</span><span class="s1">).split(os.pathsep):</span>
            <span class="s2">if </span><span class="s1">dir:</span>
                <span class="s1">self.add_include_dir(dir.rstrip(os.sep))</span>

        <span class="s2">for </span><span class="s1">dir </span><span class="s2">in </span><span class="s1">vc_env.get(</span><span class="s3">'lib'</span><span class="s1">, </span><span class="s3">''</span><span class="s1">).split(os.pathsep):</span>
            <span class="s2">if </span><span class="s1">dir:</span>
                <span class="s1">self.add_library_dir(dir.rstrip(os.sep))</span>

        <span class="s1">self.preprocess_options = </span><span class="s2">None</span>
        <span class="s0"># bpo-38597: Always compile with dynamic linking</span>
        <span class="s0"># Future releases of Python 3.x will include all past</span>
        <span class="s0"># versions of vcruntime*.dll for compatibility.</span>
        <span class="s1">self.compile_options = [</span>
            <span class="s3">'/nologo'</span><span class="s1">, </span><span class="s3">'/Ox'</span><span class="s1">, </span><span class="s3">'/W3'</span><span class="s1">, </span><span class="s3">'/GL'</span><span class="s1">, </span><span class="s3">'/DNDEBUG'</span><span class="s1">, </span><span class="s3">'/MD'</span>
        <span class="s1">]</span>

        <span class="s1">self.compile_options_debug = [</span>
            <span class="s3">'/nologo'</span><span class="s1">, </span><span class="s3">'/Od'</span><span class="s1">, </span><span class="s3">'/MDd'</span><span class="s1">, </span><span class="s3">'/Zi'</span><span class="s1">, </span><span class="s3">'/W3'</span><span class="s1">, </span><span class="s3">'/D_DEBUG'</span>
        <span class="s1">]</span>

        <span class="s1">ldflags = [</span>
            <span class="s3">'/nologo'</span><span class="s1">, </span><span class="s3">'/INCREMENTAL:NO'</span><span class="s1">, </span><span class="s3">'/LTCG'</span>
        <span class="s1">]</span>

        <span class="s1">ldflags_debug = [</span>
            <span class="s3">'/nologo'</span><span class="s1">, </span><span class="s3">'/INCREMENTAL:NO'</span><span class="s1">, </span><span class="s3">'/LTCG'</span><span class="s1">, </span><span class="s3">'/DEBUG:FULL'</span>
        <span class="s1">]</span>

        <span class="s1">self.ldflags_exe = [*ldflags, </span><span class="s3">'/MANIFEST:EMBED,ID=1'</span><span class="s1">]</span>
        <span class="s1">self.ldflags_exe_debug = [*ldflags_debug, </span><span class="s3">'/MANIFEST:EMBED,ID=1'</span><span class="s1">]</span>
        <span class="s1">self.ldflags_shared = [*ldflags, </span><span class="s3">'/DLL'</span><span class="s1">, </span><span class="s3">'/MANIFEST:EMBED,ID=2'</span><span class="s1">, </span><span class="s3">'/MANIFESTUAC:NO'</span><span class="s1">]</span>
        <span class="s1">self.ldflags_shared_debug = [*ldflags_debug, </span><span class="s3">'/DLL'</span><span class="s1">, </span><span class="s3">'/MANIFEST:EMBED,ID=2'</span><span class="s1">, </span><span class="s3">'/MANIFESTUAC:NO'</span><span class="s1">]</span>
        <span class="s1">self.ldflags_static = [*ldflags]</span>
        <span class="s1">self.ldflags_static_debug = [*ldflags_debug]</span>

        <span class="s1">self._ldflags = {</span>
            <span class="s1">(CCompiler.EXECUTABLE, </span><span class="s2">None</span><span class="s1">): self.ldflags_exe,</span>
            <span class="s1">(CCompiler.EXECUTABLE, </span><span class="s2">False</span><span class="s1">): self.ldflags_exe,</span>
            <span class="s1">(CCompiler.EXECUTABLE, </span><span class="s2">True</span><span class="s1">): self.ldflags_exe_debug,</span>
            <span class="s1">(CCompiler.SHARED_OBJECT, </span><span class="s2">None</span><span class="s1">): self.ldflags_shared,</span>
            <span class="s1">(CCompiler.SHARED_OBJECT, </span><span class="s2">False</span><span class="s1">): self.ldflags_shared,</span>
            <span class="s1">(CCompiler.SHARED_OBJECT, </span><span class="s2">True</span><span class="s1">): self.ldflags_shared_debug,</span>
            <span class="s1">(CCompiler.SHARED_LIBRARY, </span><span class="s2">None</span><span class="s1">): self.ldflags_static,</span>
            <span class="s1">(CCompiler.SHARED_LIBRARY, </span><span class="s2">False</span><span class="s1">): self.ldflags_static,</span>
            <span class="s1">(CCompiler.SHARED_LIBRARY, </span><span class="s2">True</span><span class="s1">): self.ldflags_static_debug,</span>
        <span class="s1">}</span>

        <span class="s1">self.initialized = </span><span class="s2">True</span>

    <span class="s0"># -- Worker methods ------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">object_filenames(self,</span>
                         <span class="s1">source_filenames,</span>
                         <span class="s1">strip_dir=</span><span class="s4">0</span><span class="s1">,</span>
                         <span class="s1">output_dir=</span><span class="s3">''</span><span class="s1">):</span>
        <span class="s1">ext_map = {</span>
            <span class="s1">**{ext: self.obj_extension </span><span class="s2">for </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">self.src_extensions},</span>
            <span class="s1">**{ext: self.res_extension </span><span class="s2">for </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">self._rc_extensions + self._mc_extensions},</span>
        <span class="s1">}</span>

        <span class="s1">output_dir = output_dir </span><span class="s2">or </span><span class="s3">''</span>

        <span class="s2">def </span><span class="s1">make_out_path(p):</span>
            <span class="s1">base, ext = os.path.splitext(p)</span>
            <span class="s2">if </span><span class="s1">strip_dir:</span>
                <span class="s1">base = os.path.basename(base)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">_, base = os.path.splitdrive(base)</span>
                <span class="s2">if </span><span class="s1">base.startswith((os.path.sep, os.path.altsep)):</span>
                    <span class="s1">base = base[</span><span class="s4">1</span><span class="s1">:]</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s0"># XXX: This may produce absurdly long paths. We should check</span>
                <span class="s0"># the length of the result and trim base until we fit within</span>
                <span class="s0"># 260 characters.</span>
                <span class="s2">return </span><span class="s1">os.path.join(output_dir, base + ext_map[ext])</span>
            <span class="s2">except </span><span class="s1">LookupError:</span>
                <span class="s0"># Better to raise an exception instead of silently continuing</span>
                <span class="s0"># and later complain about sources and targets having</span>
                <span class="s0"># different lengths</span>
                <span class="s2">raise </span><span class="s1">CompileError(</span><span class="s3">&quot;Don't know how to compile {}&quot;</span><span class="s1">.format(p))</span>

        <span class="s2">return </span><span class="s1">list(map(make_out_path, source_filenames))</span>


    <span class="s2">def </span><span class="s1">compile(self, sources,</span>
                <span class="s1">output_dir=</span><span class="s2">None</span><span class="s1">, macros=</span><span class="s2">None</span><span class="s1">, include_dirs=</span><span class="s2">None</span><span class="s1">, debug=</span><span class="s4">0</span><span class="s1">,</span>
                <span class="s1">extra_preargs=</span><span class="s2">None</span><span class="s1">, extra_postargs=</span><span class="s2">None</span><span class="s1">, depends=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s2">if not </span><span class="s1">self.initialized:</span>
            <span class="s1">self.initialize()</span>
        <span class="s1">compile_info = self._setup_compile(output_dir, macros, include_dirs,</span>
                                           <span class="s1">sources, depends, extra_postargs)</span>
        <span class="s1">macros, objects, extra_postargs, pp_opts, build = compile_info</span>

        <span class="s1">compile_opts = extra_preargs </span><span class="s2">or </span><span class="s1">[]</span>
        <span class="s1">compile_opts.append(</span><span class="s3">'/c'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">debug:</span>
            <span class="s1">compile_opts.extend(self.compile_options_debug)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">compile_opts.extend(self.compile_options)</span>


        <span class="s1">add_cpp_opts = </span><span class="s2">False</span>

        <span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">objects:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">src, ext = build[obj]</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">debug:</span>
                <span class="s0"># pass the full pathname to MSVC in debug mode,</span>
                <span class="s0"># this allows the debugger to find the source file</span>
                <span class="s0"># without asking the user to browse for it</span>
                <span class="s1">src = os.path.abspath(src)</span>

            <span class="s2">if </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">self._c_extensions:</span>
                <span class="s1">input_opt = </span><span class="s3">&quot;/Tc&quot; </span><span class="s1">+ src</span>
            <span class="s2">elif </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">self._cpp_extensions:</span>
                <span class="s1">input_opt = </span><span class="s3">&quot;/Tp&quot; </span><span class="s1">+ src</span>
                <span class="s1">add_cpp_opts = </span><span class="s2">True</span>
            <span class="s2">elif </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">self._rc_extensions:</span>
                <span class="s0"># compile .RC to .RES file</span>
                <span class="s1">input_opt = src</span>
                <span class="s1">output_opt = </span><span class="s3">&quot;/fo&quot; </span><span class="s1">+ obj</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">self.spawn([self.rc] + pp_opts + [output_opt, input_opt])</span>
                <span class="s2">except </span><span class="s1">DistutilsExecError </span><span class="s2">as </span><span class="s1">msg:</span>
                    <span class="s2">raise </span><span class="s1">CompileError(msg)</span>
                <span class="s2">continue</span>
            <span class="s2">elif </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">self._mc_extensions:</span>
                <span class="s0"># Compile .MC to .RC file to .RES file.</span>
                <span class="s0">#   * '-h dir' specifies the directory for the</span>
                <span class="s0">#     generated include file</span>
                <span class="s0">#   * '-r dir' specifies the target directory of the</span>
                <span class="s0">#     generated RC file and the binary message resource</span>
                <span class="s0">#     it includes</span>
                <span class="s0">#</span>
                <span class="s0"># For now (since there are no options to change this),</span>
                <span class="s0"># we use the source-directory for the include file and</span>
                <span class="s0"># the build directory for the RC file and message</span>
                <span class="s0"># resources. This works at least for win32all.</span>
                <span class="s1">h_dir = os.path.dirname(src)</span>
                <span class="s1">rc_dir = os.path.dirname(obj)</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s0"># first compile .MC to .RC and .H file</span>
                    <span class="s1">self.spawn([self.mc, </span><span class="s3">'-h'</span><span class="s1">, h_dir, </span><span class="s3">'-r'</span><span class="s1">, rc_dir, src])</span>
                    <span class="s1">base, _ = os.path.splitext(os.path.basename (src))</span>
                    <span class="s1">rc_file = os.path.join(rc_dir, base + </span><span class="s3">'.rc'</span><span class="s1">)</span>
                    <span class="s0"># then compile .RC to .RES file</span>
                    <span class="s1">self.spawn([self.rc, </span><span class="s3">&quot;/fo&quot; </span><span class="s1">+ obj, rc_file])</span>

                <span class="s2">except </span><span class="s1">DistutilsExecError </span><span class="s2">as </span><span class="s1">msg:</span>
                    <span class="s2">raise </span><span class="s1">CompileError(msg)</span>
                <span class="s2">continue</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># how to handle this file?</span>
                <span class="s2">raise </span><span class="s1">CompileError(</span><span class="s3">&quot;Don't know how to compile {} to {}&quot;</span>
                                   <span class="s1">.format(src, obj))</span>

            <span class="s1">args = [self.cc] + compile_opts + pp_opts</span>
            <span class="s2">if </span><span class="s1">add_cpp_opts:</span>
                <span class="s1">args.append(</span><span class="s3">'/EHsc'</span><span class="s1">)</span>
            <span class="s1">args.append(input_opt)</span>
            <span class="s1">args.append(</span><span class="s3">&quot;/Fo&quot; </span><span class="s1">+ obj)</span>
            <span class="s1">args.extend(extra_postargs)</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.spawn(args)</span>
            <span class="s2">except </span><span class="s1">DistutilsExecError </span><span class="s2">as </span><span class="s1">msg:</span>
                <span class="s2">raise </span><span class="s1">CompileError(msg)</span>

        <span class="s2">return </span><span class="s1">objects</span>


    <span class="s2">def </span><span class="s1">create_static_lib(self,</span>
                          <span class="s1">objects,</span>
                          <span class="s1">output_libname,</span>
                          <span class="s1">output_dir=</span><span class="s2">None</span><span class="s1">,</span>
                          <span class="s1">debug=</span><span class="s4">0</span><span class="s1">,</span>
                          <span class="s1">target_lang=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s2">if not </span><span class="s1">self.initialized:</span>
            <span class="s1">self.initialize()</span>
        <span class="s1">objects, output_dir = self._fix_object_args(objects, output_dir)</span>
        <span class="s1">output_filename = self.library_filename(output_libname,</span>
                                                <span class="s1">output_dir=output_dir)</span>

        <span class="s2">if </span><span class="s1">self._need_link(objects, output_filename):</span>
            <span class="s1">lib_args = objects + [</span><span class="s3">'/OUT:' </span><span class="s1">+ output_filename]</span>
            <span class="s2">if </span><span class="s1">debug:</span>
                <span class="s2">pass </span><span class="s0"># XXX what goes here?</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">log.debug(</span><span class="s3">'Executing &quot;%s&quot; %s'</span><span class="s1">, self.lib, </span><span class="s3">' '</span><span class="s1">.join(lib_args))</span>
                <span class="s1">self.spawn([self.lib] + lib_args)</span>
            <span class="s2">except </span><span class="s1">DistutilsExecError </span><span class="s2">as </span><span class="s1">msg:</span>
                <span class="s2">raise </span><span class="s1">LibError(msg)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">log.debug(</span><span class="s3">&quot;skipping %s (up-to-date)&quot;</span><span class="s1">, output_filename)</span>


    <span class="s2">def </span><span class="s1">link(self,</span>
             <span class="s1">target_desc,</span>
             <span class="s1">objects,</span>
             <span class="s1">output_filename,</span>
             <span class="s1">output_dir=</span><span class="s2">None</span><span class="s1">,</span>
             <span class="s1">libraries=</span><span class="s2">None</span><span class="s1">,</span>
             <span class="s1">library_dirs=</span><span class="s2">None</span><span class="s1">,</span>
             <span class="s1">runtime_library_dirs=</span><span class="s2">None</span><span class="s1">,</span>
             <span class="s1">export_symbols=</span><span class="s2">None</span><span class="s1">,</span>
             <span class="s1">debug=</span><span class="s4">0</span><span class="s1">,</span>
             <span class="s1">extra_preargs=</span><span class="s2">None</span><span class="s1">,</span>
             <span class="s1">extra_postargs=</span><span class="s2">None</span><span class="s1">,</span>
             <span class="s1">build_temp=</span><span class="s2">None</span><span class="s1">,</span>
             <span class="s1">target_lang=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s2">if not </span><span class="s1">self.initialized:</span>
            <span class="s1">self.initialize()</span>
        <span class="s1">objects, output_dir = self._fix_object_args(objects, output_dir)</span>
        <span class="s1">fixed_args = self._fix_lib_args(libraries, library_dirs,</span>
                                        <span class="s1">runtime_library_dirs)</span>
        <span class="s1">libraries, library_dirs, runtime_library_dirs = fixed_args</span>

        <span class="s2">if </span><span class="s1">runtime_library_dirs:</span>
            <span class="s1">self.warn(</span><span class="s3">&quot;I don't know what to do with 'runtime_library_dirs': &quot;</span>
                       <span class="s1">+ str(runtime_library_dirs))</span>

        <span class="s1">lib_opts = gen_lib_options(self,</span>
                                   <span class="s1">library_dirs, runtime_library_dirs,</span>
                                   <span class="s1">libraries)</span>
        <span class="s2">if </span><span class="s1">output_dir </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">output_filename = os.path.join(output_dir, output_filename)</span>

        <span class="s2">if </span><span class="s1">self._need_link(objects, output_filename):</span>
            <span class="s1">ldflags = self._ldflags[target_desc, debug]</span>

            <span class="s1">export_opts = [</span><span class="s3">&quot;/EXPORT:&quot; </span><span class="s1">+ sym </span><span class="s2">for </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">(export_symbols </span><span class="s2">or </span><span class="s1">[])]</span>

            <span class="s1">ld_args = (ldflags + lib_opts + export_opts +</span>
                       <span class="s1">objects + [</span><span class="s3">'/OUT:' </span><span class="s1">+ output_filename])</span>

            <span class="s0"># The MSVC linker generates .lib and .exp files, which cannot be</span>
            <span class="s0"># suppressed by any linker switches. The .lib files may even be</span>
            <span class="s0"># needed! Make sure they are generated in the temporary build</span>
            <span class="s0"># directory. Since they have different names for debug and release</span>
            <span class="s0"># builds, they can go into the same directory.</span>
            <span class="s1">build_temp = os.path.dirname(objects[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">export_symbols </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">(dll_name, dll_ext) = os.path.splitext(</span>
                    <span class="s1">os.path.basename(output_filename))</span>
                <span class="s1">implib_file = os.path.join(</span>
                    <span class="s1">build_temp,</span>
                    <span class="s1">self.library_filename(dll_name))</span>
                <span class="s1">ld_args.append (</span><span class="s3">'/IMPLIB:' </span><span class="s1">+ implib_file)</span>

            <span class="s2">if </span><span class="s1">extra_preargs:</span>
                <span class="s1">ld_args[:</span><span class="s4">0</span><span class="s1">] = extra_preargs</span>
            <span class="s2">if </span><span class="s1">extra_postargs:</span>
                <span class="s1">ld_args.extend(extra_postargs)</span>

            <span class="s1">output_dir = os.path.dirname(os.path.abspath(output_filename))</span>
            <span class="s1">self.mkpath(output_dir)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">log.debug(</span><span class="s3">'Executing &quot;%s&quot; %s'</span><span class="s1">, self.linker, </span><span class="s3">' '</span><span class="s1">.join(ld_args))</span>
                <span class="s1">self.spawn([self.linker] + ld_args)</span>
            <span class="s2">except </span><span class="s1">DistutilsExecError </span><span class="s2">as </span><span class="s1">msg:</span>
                <span class="s2">raise </span><span class="s1">LinkError(msg)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">log.debug(</span><span class="s3">&quot;skipping %s (up-to-date)&quot;</span><span class="s1">, output_filename)</span>

    <span class="s2">def </span><span class="s1">spawn(self, cmd):</span>
        <span class="s1">env = dict(os.environ, PATH=self._paths)</span>
        <span class="s2">return </span><span class="s1">super().spawn(cmd, env=env)</span>

    <span class="s0"># -- Miscellaneous methods -----------------------------------------</span>
    <span class="s0"># These are all used by the 'gen_lib_options() function, in</span>
    <span class="s0"># ccompiler.py.</span>

    <span class="s2">def </span><span class="s1">library_dir_option(self, dir):</span>
        <span class="s2">return </span><span class="s3">&quot;/LIBPATH:&quot; </span><span class="s1">+ dir</span>

    <span class="s2">def </span><span class="s1">runtime_library_dir_option(self, dir):</span>
        <span class="s2">raise </span><span class="s1">DistutilsPlatformError(</span>
              <span class="s3">&quot;don't know how to set runtime library search path for MSVC&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">library_option(self, lib):</span>
        <span class="s2">return </span><span class="s1">self.library_filename(lib)</span>

    <span class="s2">def </span><span class="s1">find_library_file(self, dirs, lib, debug=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s0"># Prefer a debugging library if found (and requested), but deal</span>
        <span class="s0"># with it if we don't have one.</span>
        <span class="s2">if </span><span class="s1">debug:</span>
            <span class="s1">try_names = [lib + </span><span class="s3">&quot;_d&quot;</span><span class="s1">, lib]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">try_names = [lib]</span>
        <span class="s2">for </span><span class="s1">dir </span><span class="s2">in </span><span class="s1">dirs:</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">try_names:</span>
                <span class="s1">libfile = os.path.join(dir, self.library_filename(name))</span>
                <span class="s2">if </span><span class="s1">os.path.isfile(libfile):</span>
                    <span class="s2">return </span><span class="s1">libfile</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># Oops, didn't find it in *any* of 'dirs'</span>
            <span class="s2">return None</span>
</pre>
</body>
</html>